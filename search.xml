<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[IDEA创建第一个maven-web项目]]></title>
    <url>%2F2019%2F06%2F18%2FIntellij-IDEA%2Fidea%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AAmaven-web%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[IDEA创建WEB项目 用惯了eclipse，这段时间刚接触Idea编辑工具，这款神器是真的好用，兄弟们用起来!!! 但在创建maven web项目的一些步骤有些不熟悉，在这里介绍一下常用的maven web项目的创建过程。 1.步骤一：首先先创建一个project,在这里就是创建一个maven的工作空间 2.步骤二：选择左边的maven，然后在右边Creater from archetype选项前面打个勾,并且选择(maven-archetype-webapp),接着点击next 3.步骤三：填写你的Group Id（一般写公司名）跟 ArtifictId（一般写项目名） 4.步骤四：选择自己下载好的apache-maven. 5.步骤五：继续一路finish，等待idea加载出目录结构 如果目录没有出来，则点击更新操作。 6.步骤六：项目的基本目录结构出来后,我们还需为项目配置下编译路径还有artifact，操作如下 7.步骤七：配置tomcat本地服务器，运行项目]]></content>
      <categories>
        <category>Intellij IDEA</category>
      </categories>
      <tags>
        <tag>编辑器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逆向工程在idea开发项目的使用]]></title>
    <url>%2F2019%2F06%2F18%2FWeb%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%2F%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF-%E3%80%90%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E3%80%91%2F%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E5%9C%A8idea%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[逆向工程技术的使用一、逆向工程 逆向工程：mybaits需要程序员自己编写sql语句，编写过程比较繁琐。因此mybatis官方提供逆向工程mybatis-generator,可以根据表与表之间的关系，自动生成mybatis执行所需要的代码（mapper.java,mapper.xml,pojo） 二、逆向工程的准备1.建立一个数据库表（你要操作的） 2.jar包准备（pom.xml引入依赖包，下面引入包比较多，可根据需要引入）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.yy&lt;/groupId&gt; &lt;artifactId&gt;YYcoder&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;YYcoder Maven Webapp&lt;/name&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;spring.version&gt;4.1.4.RELEASE&lt;/spring.version&gt; &lt;jackson.version&gt;2.5.0&lt;/jackson.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- spring 所有核心包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- mybatis 包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.2.8&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis spring 整合 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql连接 注意版本--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据源 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.12&lt;/version&gt; &lt;/dependency&gt; &lt;!-- aspectjweaver是spring的切入点表达式需要用的包， --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log4j --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;!-- servlet --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;3.0-alpha-1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- jstl --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- java对象和json相互转化 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt; &lt;version&gt;1.9.13&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 后台转化为json格式 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- springmvc框架整合AJAX使用@ResponseBody需要此包 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 基本的序列化和反序列化 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 将JSON格式的数据转化为类对象 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 文件上传 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis-generator-core 反向生成java代码--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 文件上传 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis-redis整合依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt; &lt;artifactId&gt;mybatis-redis&lt;/artifactId&gt; &lt;version&gt;1.0.0-beta2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring 整合 redis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt; &lt;version&gt;1.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- jedis 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;YYcoder&lt;/finalName&gt; &lt;plugins&gt; &lt;!-- 资源文件拷贝插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;2.7&lt;/version&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- java编译插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.2&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- 配置Tomcat插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!--逆向工程插件--&gt; &lt;!-- mybatis generator 自动生成代码插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.5&lt;/version&gt; &lt;configuration&gt; &lt;!-- 配置文件路径 --&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt;&lt;/project&gt; 3.编写generatorConfig.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot; &gt;&lt;generatorConfiguration &gt; &lt;!-- mysql jar 文件位置 --&gt; &lt;context id=&quot;store&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;commentGenerator&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt; &lt;!-- 是否去除所有自动生成的文件的时间戳，默认为false --&gt; &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt; &lt;/commentGenerator&gt; &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/yy_mysql&quot; userId=&quot;root&quot; password=&quot;cyy493610&quot;&gt; &lt;/jdbcConnection&gt; &lt;!-- targetPackage:包名称(自定义) targetProject：项目路径(自定义) --&gt; &lt;!--定义model的包名称--&gt; &lt;javaModelGenerator targetPackage=&quot;com.YYcoder.entity&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;!-- 从数据库返回的值被清理前后的空格 --&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt; &lt;/javaModelGenerator&gt; &lt;!-- 配置生成相应的实体Mapper.xml，对于Mapper3.X我们需要把type=&quot;XMLMAPPER&quot; --&gt; &lt;!-- targetPackage:包名称(自定义) targetProject：项目路径(自定义) --&gt; &lt;sqlMapGenerator targetPackage=&quot;com.YYcoder.mapper&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 配置生成相应的接口类，对应与Mapper.xml中的一系列CRUD方法SQL语句 --&gt; &lt;!-- targetPackage:包名称(自定义) targetProject：项目路径(自定义) --&gt; &lt;javaClientGenerator targetPackage=&quot;com.YYcoder.mapper&quot; targetProject=&quot;src/main/java&quot; type=&quot;XMLMAPPER&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 数据库表名 --&gt; &lt;!-- 取消生成example类--&gt; &lt;table tableName= &quot;address&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;&gt;&lt;/table&gt; &lt;table tableName= &quot;admin&quot; &gt;&lt;/table&gt; &lt;table tableName= &quot;category&quot; &gt;&lt;/table&gt; &lt;table tableName= &quot;goods&quot; &gt;&lt;/table&gt; &lt;table tableName= &quot;imagepath&quot; &gt;&lt;/table&gt; &lt;table tableName= &quot;order&quot; &gt;&lt;/table&gt; &lt;table tableName= &quot;oderitem&quot; &gt;&lt;/table&gt; &lt;table tableName= &quot;shop&quot; &gt;&lt;/table&gt; &lt;table tableName= &quot;shopcart&quot; &gt;&lt;/table&gt; &lt;table tableName= &quot;user&quot; &gt;&lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 4.编写测试类MyGenerator.java,运行生成对应的文件123456789101112131415161718192021222324252627282930313233package com.YYcoder.Test;import org.mybatis.generator.api.MyBatisGenerator;import org.mybatis.generator.config.Configuration;import org.mybatis.generator.config.xml.ConfigurationParser;import org.mybatis.generator.internal.DefaultShellCallback;import java.io.File;import java.util.ArrayList;import java.util.List;//编写java启动类，执行逆向工程的配置文件，生成数据库中指定表的model和dao层：// （注意：启动类中创建File中的路径是从本项目中开始的，需要找到从项目开始写起，直到找到配置文件的路径即可）public class MyGenerator &#123; public void generate() throws Exception &#123; List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; File configFile = new File(&quot;./src/main/resources/generatorConfig.xml&quot;); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null); &#125; public static void main(String[] args) throws Exception &#123; try &#123; MyGenerator myGenerator = new MyGenerator(); myGenerator.generate(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 5.运行后，相应的包会出现对应的文件，即为操作成功]]></content>
      <categories>
        <category>Web后端技术</category>
        <category>工程技术--【逆向工程】</category>
      </categories>
      <tags>
        <tag>工程技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux学习记录（一）--- 基础入门篇]]></title>
    <url>%2F2019%2F06%2F01%2FWeb%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%2F%E3%80%90Linux%E5%AD%A6%E4%B9%A0%E3%80%91%2Flinux%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AF%87%2F</url>
    <content type="text"><![CDATA[什么是Linux？]]></content>
      <categories>
        <category>Web后端技术</category>
        <category>【Linux学习】</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot(一)：入门篇]]></title>
    <url>%2F2019%2F05%2F16%2FWeb%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%2F%E3%80%90SpringBoot%E5%AD%A6%E4%B9%A0%E3%80%91%2Fspring-boot-%E4%B8%80-%EF%BC%9A%E5%85%A5%E9%97%A8%E7%AF%87%2F</url>
    <content type="text"><![CDATA[构建微服务：Spring boot 入门篇什么是Spring Boot?Spring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。其实Spring Boot 不是什么新的框架，它只是默认配置了很多框架的使用方式，就像 Maven 整合了所有的 Jar 包，Spring Boot 整合了所有的框架。 使用 Spring Boot有什么好处其实就是简单、快速、方便！平时如果我们需要搭建一个 Spring Web 项目的时候需要怎么做呢？ 1）配置 web.xml，加载 Spring 和 Spring mvc 2）配置数据库连接、配置 Spring 事务 3）配置加载配置文件的读取，开启注解 4）配置日志文件 ···· 配置完成之后部署 Tomcat 调试想象一下如果生产项目，只是为了实现简单的一个发送消息的功能，都需要这样折腾一遍! 但是如果使用 Spring Boot 呢？ 很简单，我仅仅只需要非常少的几个配置就可以迅速方便的搭建起来一套 Web 项目或者是构建一个微服务！ 快速入门 说了那么多，不如马上来动手试一试! Maven 构建项目 1、访问 http://start.spring.io/ 2、选择构建工具 Maven Project、Java、Spring Boot 版本 2.1.5 以及一些工程基本信息，可参考下图 所示： 3、点击 Generate Project 下载项目压缩包 4、解压后，使用 Idea 导入项目，File -&gt; New -&gt; Model from Existing Source.. -&gt; 选择解压后的文件夹 -&gt; OK，选择 Maven 一路 Next，OK done! 5、如果使用的是 Eclipse，Import -&gt; Existing Maven Projects -&gt; Next -&gt; 选择解压后的文件夹 -&gt; Finsh，OK done! Idea 构建项目 1、选择 File -&gt; New —&gt; Project… 弹出新建项目的框 2、选择 Spring Initializr，Next 也会出现上述类似的配置界面，Idea 帮我们做了集成 3、填写相关内容后，点击 Next 选择依赖的包再点击 Next，最后确定信息无误点击 Finish。 项目结构介绍 如上图所示，Spring Boot的基础结构共三个文件: src/main/java 程序开发以及主程序入口 src/main/resources 配置文件 src/test/java 测试程序 另外，spingboot建议的目录结果如下： root package结构：com.example.myproject 123456789101112131415com +- example +- myproject +- Application.java | +- domain | +- Customer.java | +- CustomerRepository.java | +- service | +- CustomerService.java | +- controller | +- CustomerController.java | 1、Application.java 建议放到跟目录下面,主要用于做一些框架配置 2、domain目录主要用于实体（Entity）与数据访问层（Repository） 3、service 层主要是业务类代码 4、controller 负责页面访问控制 采用默认配置可以省去很多配置，当然也可以根据自己的喜欢来进行更改最后，启动Application main方法，至此一个java项目搭建好了！ 引入 Web 模块1、pom.xml中添加支持web的模块：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; pom.xml文件中默认有两个模块： spring-boot-starter：核心模块，包括自动配置支持、日志和YAML； spring-boot-starter-test：测试模块，包括JUnit、Hamcrest、Mockito。 2、编写controller内容1234567@RestControllerpublic class HelloWorldController &#123; @RequestMapping(&quot;/hello&quot;) public String index() &#123; return &quot;Hello World&quot;; &#125;&#125; @RestController的意思就是controller里面的方法都以json格式输出，不用再写什么jackjson配置的了！ 3、启动主程序，打开浏览器访问http://localhost:8080/hello, 就可以看到效果了，是不是很简单粗暴！ 如何做单元测试打开的src/test/下的测试入口，编写简单的http请求来测试；使用mockmvc进行，利用MockMvcResultHandlers.print() 打印出执行结果。1234567891011121314151617 @RunWith(SpringRunner.class) @SpringBootTest public class HelloWorldControlerTests &#123; private MockMvc mvc; @Before public void setUp() throws Exception &#123; mvc = MockMvcBuilders.standaloneSetup(new HelloWorldController()).build(); &#125; @Test public void getHello() throws Exception &#123; mvc.perform(MockMvcRequestBuilders.get(&quot;/hello&quot;).accept(MediaType.APPLICATION_JSON)) .andExpect(MockMvcResultMatchers.status().isOk()) .andDo(MockMvcResultHandlers.print()) .andReturn(); &#125;&#125; 开发环境的调试热启动在正常开发项目中已经很常见了吧，虽然平时开发 web 项目过程中，改动项目启重启总是报错；但Spring Boot对调试支持很好，修改之后可以实时生效，需要添加以下的配置： 1234567891011121314151617181920212223242526272829303132333435&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 该模块在完整的打包环境下运行的时候会被禁用。如果你使用java -jar启动应用或者用一个特定的classloader启动，它会认为这是一个“生产环境”。 总结使用 Spring Boot 可以非常方便、快速搭建项目，使我们不用关心框架之间的兼容性，适用版本等各种问题，我们想使用任何东西，仅仅添加一个配置就可以，所以使用 Spring Boot 非常适合构建微服务。]]></content>
      <categories>
        <category>Web后端技术</category>
        <category>【SpringBoot学习】</category>
      </categories>
      <tags>
        <tag>框架学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot(一)：入门篇]]></title>
    <url>%2F2019%2F05%2F16%2FWeb%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%2F%E3%80%90SpringBoot%E5%AD%A6%E4%B9%A0%E3%80%91%2Fspring-boot-%E4%B8%80-%EF%BC%9A%E5%85%A5%E9%97%A8%E7%AF%87%2F</url>
    <content type="text"><![CDATA[构建微服务：Spring boot 入门篇什么是Spring Boot?Spring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。其实Spring Boot 不是什么新的框架，它只是默认配置了很多框架的使用方式，就像 Maven 整合了所有的 Jar 包，Spring Boot 整合了所有的框架。 使用 Spring Boot有什么好处其实就是简单、快速、方便！平时如果我们需要搭建一个 Spring Web 项目的时候需要怎么做呢？ 1）配置 web.xml，加载 Spring 和 Spring mvc 2）配置数据库连接、配置 Spring 事务 3）配置加载配置文件的读取，开启注解 4）配置日志文件 ···· 配置完成之后部署 Tomcat 调试想象一下如果生产项目，只是为了实现简单的一个发送消息的功能，都需要这样折腾一遍! 但是如果使用 Spring Boot 呢？ 很简单，我仅仅只需要非常少的几个配置就可以迅速方便的搭建起来一套 Web 项目或者是构建一个微服务！ 快速入门 说了那么多，不如马上来动手试一试! Maven 构建项目 1、访问 http://start.spring.io/ 2、选择构建工具 Maven Project、Java、Spring Boot 版本 2.1.5 以及一些工程基本信息，可参考下图 所示： 3、点击 Generate Project 下载项目压缩包 4、解压后，使用 Idea 导入项目，File -&gt; New -&gt; Model from Existing Source.. -&gt; 选择解压后的文件夹 -&gt; OK，选择 Maven 一路 Next，OK done! 5、如果使用的是 Eclipse，Import -&gt; Existing Maven Projects -&gt; Next -&gt; 选择解压后的文件夹 -&gt; Finsh，OK done! Idea 构建项目 1、选择 File -&gt; New —&gt; Project… 弹出新建项目的框 2、选择 Spring Initializr，Next 也会出现上述类似的配置界面，Idea 帮我们做了集成 3、填写相关内容后，点击 Next 选择依赖的包再点击 Next，最后确定信息无误点击 Finish。 项目结构介绍 如上图所示，Spring Boot的基础结构共三个文件: src/main/java 程序开发以及主程序入口 src/main/resources 配置文件 src/test/java 测试程序 另外，spingboot建议的目录结果如下： root package结构：com.example.myproject 123456789101112131415com +- example +- myproject +- Application.java | +- domain | +- Customer.java | +- CustomerRepository.java | +- service | +- CustomerService.java | +- controller | +- CustomerController.java | 1、Application.java 建议放到跟目录下面,主要用于做一些框架配置 2、domain目录主要用于实体（Entity）与数据访问层（Repository） 3、service 层主要是业务类代码 4、controller 负责页面访问控制 采用默认配置可以省去很多配置，当然也可以根据自己的喜欢来进行更改最后，启动Application main方法，至此一个java项目搭建好了！ 引入 Web 模块1、pom.xml中添加支持web的模块：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; pom.xml文件中默认有两个模块： spring-boot-starter：核心模块，包括自动配置支持、日志和YAML； spring-boot-starter-test：测试模块，包括JUnit、Hamcrest、Mockito。 2、编写controller内容1234567@RestControllerpublic class HelloWorldController &#123; @RequestMapping(&quot;/hello&quot;) public String index() &#123; return &quot;Hello World&quot;; &#125;&#125; @RestController的意思就是controller里面的方法都以json格式输出，不用再写什么jackjson配置的了！ 3、启动主程序，打开浏览器访问http://localhost:8080/hello, 就可以看到效果了，是不是很简单粗暴！ 如何做单元测试打开的src/test/下的测试入口，编写简单的http请求来测试；使用mockmvc进行，利用MockMvcResultHandlers.print() 打印出执行结果。1234567891011121314151617 @RunWith(SpringRunner.class) @SpringBootTest public class HelloWorldControlerTests &#123; private MockMvc mvc; @Before public void setUp() throws Exception &#123; mvc = MockMvcBuilders.standaloneSetup(new HelloWorldController()).build(); &#125; @Test public void getHello() throws Exception &#123; mvc.perform(MockMvcRequestBuilders.get(&quot;/hello&quot;).accept(MediaType.APPLICATION_JSON)) .andExpect(MockMvcResultMatchers.status().isOk()) .andDo(MockMvcResultHandlers.print()) .andReturn(); &#125;&#125; 开发环境的调试热启动在正常开发项目中已经很常见了吧，虽然平时开发 web 项目过程中，改动项目启重启总是报错；但Spring Boot对调试支持很好，修改之后可以实时生效，需要添加以下的配置： 1234567891011121314151617181920212223242526272829303132333435&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 该模块在完整的打包环境下运行的时候会被禁用。如果你使用java -jar启动应用或者用一个特定的classloader启动，它会认为这是一个“生产环境”。 总结使用 Spring Boot 可以非常方便、快速搭建项目，使我们不用关心框架之间的兼容性，适用版本等各种问题，我们想使用任何东西，仅仅添加一个配置就可以，所以使用 Spring Boot 非常适合构建微服务。]]></content>
      <categories>
        <category>Web后端技术</category>
        <category>【SpringBoot学习】</category>
      </categories>
      <tags>
        <tag>框架学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL基础笔记（2）-- SQL语言]]></title>
    <url>%2F2019%2F05%2F14%2FJavaWeb%2F%E3%80%90MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%91%2Fmysql%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89-sql%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[什么是SQL查询语言？SQL是Structured Quevy Language(结构化查询语言)的缩写。 SQL是专为数据库而建立的操作命令集，是一种功能齐全的数据库语言。在使用它时，只需要 发出“做什么”的命令，“怎么做”是不用使用者考虑的。 SQL数据类型1.常用的数据类型double：浮点型，例如double(5,2)表示最多5位，其中必须有2位小数，即最大值为999.99； char：固定长度字符串类型； char(10) &apos;abc&apos; varchar：可变长度字符串类型；varchar(10) &apos;abc&apos; text：字符串类型; blob：二进制类型； date：日期类型，格式为：yyyy-MM-dd； time：时间类型，格式为：hh:mm:ss datetime:日期时间类型 yyyy-MM-dd hh:mm:ss 在mysql中，字符串类型和日期类型都要用单引号括起来。 如’sql_study’、’2020-01-01’等 MySQL支持的数据类型大致可以分为三类1.数值类型 2.字符串类型 3.日期和时间类型 sql功能分类1.DDL: 数据定义语言DDL是用来定义数据库对象：创建库，表，列等。 创建数据库 create database 数据库名 character set utf8; 修改数据库 alter database 数据库名 charactor set gbk; 查看表的字段信息 DESC 表名; 查看表的创建细节 SHOW CREATE TABLE 表名; 修改表的字符集为gbk ALTER TABLE 表名 CHARACTER SET 字符集名称; 创建表 create table 表名(列名1 列的类型[约束]，列名2 列的类型[约束]....); 修改表名 RENAME TABLE 原始表名 TO 要修改的表名; 修改一个表的字段类型 ALTER TABLE 表名 MODIFY 字段名 数据类型 修改表的列名 ALTER TABLE 表名 CHANGE 原始列名 新列名 数据类型; 删除表 DROP TABLE 表名; 添加一列 ALTER TABLE 表名 ADD 列名 数据类型; 删除一列 ALTER TABLE 表名 DROP 字段名; 2.DML：数据操作语言DML用来操作数据库表中的记录，即就是对数据库的数据进行增删改查的操作 ①查询操作 查询表中的所有数据 SELECT * FROM 表名; 查询表中的指定数据 SELECT * FROM 表名 where 条件; ②插入操作 单个数据插入 INSERT INTO 表名（列名1，列名2 ...）VALUE (列值1，列值2...); 批量数据插入 INSERT INTO 表名（列名1，列名2 ...）VALUES (列值1，列值2...)，(列值1，列值2...); ③更新操作 更新记录 UPDATE 表名 SET 列名1=列值1，列名2=列值2 .... WHERE 列名=值; ④删除操作 删除记录 DELETE FROM 表名 【WHERE 列名=值】; (DELETE 删除表中的数据，表结构还在;删除后的数据可以找回) 删除所有记录 TRUNCATE TABLE 表名; (删除是把表直接DROP掉，然后再创建一个同样的新表。删除的数据不能找回) 3.DQL：数据查询语言DQL用来查询数据。数据库执行DQL语句不会对数据进行改变，而是让数据库发送结果集给客户端。 结果集：通过查询语句查询出来的数据以表的形式展示我们称这个表为虚拟结果集，并存放在内存中。查询返回 的结果集是一张虚拟表。 DQL包含模糊查询、条件查询、字段控制查询、排序、以及聚合函数的应用 4.DCL：数据控制语言DCL用来定义访问权限和安全级别。即对数据库事务（trasaction）的控制，包括事务的提交（commit），事务的回滚（rollback），以及权限的管理等。]]></content>
      <categories>
        <category>JavaWeb</category>
        <category>【MySQL数据库】</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL基础笔记（1）-- 数据库的介绍]]></title>
    <url>%2F2019%2F05%2F13%2FJavaWeb%2F%E3%80%90MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%91%2Fmysql%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[什么是数据库？数据库是是按照数据结构来组织、存储和管理数据的仓库。我们一般说的数据库,就是指的DBMS: 数据库服务器（是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，简称DBMS）.常见的数据库有Oracle、MySQL、SQL Server等等. Oracle: 运行稳定，可移植性高，功能齐全，性能超群！适用于大型企业领域。MySQL:开源，体积小，速度快。适用于于中小型企业领域。SQL Server: 全面，效率高，界面友好，操作容易，但是不跨平台。适用于于中小型企业领域。 数据库系统的专业术语表 具有固定的列数,和任意的行数 数据库 数据库是一些关联表的集合 列 一个数据项 Field 字段 行 一条记录（row） 主键 主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。 外键 外键用于关联两个表 索引 使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。 类似于书籍的目录。 MySQL数据库1.MySql介绍 MySQL是一个关系型数据库管理系统，属于Oracle公司。MySQL是一种关联数据库管理系统，关联数据库将数据保 存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。Mysql是开源的,而且支持 大型的数据库。可以处理拥有上千万条记录的大型数据库。 MySQL使用标准的SQL数据语言形式。 Mysql可以允许于多个系统上，并且支持多种语言。这些编程语言包括C、C++、Python、Java等。 2.MySql安装 (下载地址 https://dev.mysql.com/downloads/mysql/)3.MySql的存储引擎① 什么是存储引擎 MySQL中的数据用各种不同的技术存储在文件（或者内存）中。这些技术中的每一种技术都使用不同的存储机 制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。通过选择不同的技术，你能够获得额外的速度或 者功能，从而改善你的应用的整体功能。（不同的存储引擎性能是不一样的） ②什么是事务 是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。 4.存储引擎分类MYISAM ：它不支持事务，也不支持外键，尤其是访问速度快，对事务完整性没有要求或者以SELECT、INSERT为主的应 用基本都可以使用这个引擎来创建表。每个MyISAM在磁盘上存储成3个文件，其中文件名和表名都相同，但 是扩展名分别为：.frm(存储表定义)、MYD(MYData，存储数据)、MYI(MYIndex，存储索引) INNODB：InnoDB存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是对比MyISAM的存储引擎，InnoDB写的 处理效率差一些并且会占用更多的磁盘空间以保留数据和索引。 MEMORY：memory使用存在内存中的内容来创建表。每个MEMORY表实际对应一个磁盘文件，格式是.frm。 MEMORY类型的表访问非常快，因为它到数据是放在内存中的，并且默认使用HASH索引，但是一旦服务器关闭， 表中的数据就会丢失，但表还会继续存在。 常用数据库命令1.Mysql数据库的分类 (1)系统数据库 information_schema 存储数据库对象信息如用户表信息,列信息,根除,字符,分区里面的内容我们不能动. performance_schema 存储数据库服务器性能参数信息 mysql 存储数据库用户权限信息 sys 通过这个库可以快速的了解系统的元数据信息（这个库是通过视图的形式把information_schema 和 performance_schema结合起来，查询出更加令人容易理解的数据 (2)用户数据库 用户自己创建的数据库,一个项目用一个数据库 2.Mysql数据库命令]]></content>
      <categories>
        <category>JavaWeb</category>
        <category>【MySQL数据库】</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM三大框架之---SpringMVC]]></title>
    <url>%2F2019%2F05%2F12%2FWeb%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%2FSSM%E6%A1%86%E6%9E%B6-%E3%80%90SpringMVC%E5%AD%A6%E4%B9%A0%E3%80%91%2Fssm%E4%B8%89%E5%A4%A7%E6%A1%86%E6%9E%B6%E4%B9%8B-springmvc%2F</url>
    <content type="text"><![CDATA[表现层框架SpringMVC1.SpringMVC程序开发的基本步骤:123456789101112131415161718192021221.准备好SpringMVC开发的jar包(8个) spring-aop.jar spring-beans.jar spring-context.jar spring-core.jar spring-expression.jar commons-logging.jar spring-web.jar 在Web应用开发过程中，用到Spring框架时所需的核心类库 spring-webmvc.jar Spring MVC框架相关的所有类。如国际化、标签、Theme、FreeMarker等相关类2.在web.xml中配置前置控制器DispatcherServlet，用于拦截与&lt;url-pattern&gt;相匹配的请求 3.开发前端请求页面(index.jsp) 4.开发请求处理类(controller）：含注解@Controller、@RequestMapping()等5.在src目录下创建SpringMVC的配置文件：springmvc.xml &lt;!-- 配置需要扫描的包 --&gt; &lt;context:component-scan base-package=&quot;com.YYcoder.controller&quot;&gt; &lt;/context:component-scan&gt; &lt;!-- 配置视图解析器：把请求处理类的返回值，加工成最终的视图路径--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/views/&quot;&gt;&lt;/property&gt;&lt;!--前缀--&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;&lt;!--后缀--&gt; &lt;/bean&gt;6.开发前端结果显示页面：result.jsp 2.SpringMVC的学习内容(主要是学会如何使用注解来实现操作) ①常见注解的使用(可以参考springMVC的文档学习) @RequestMapping 用来给方法绑定一个请求映射 @PathVariable 获取动态参数 @RequestParam 获取请求参数 @RequestHeader 获取请求中的“头信息” @CookieValue 可以给处理方法入参绑定某个Cookie值 ②处理模型数据：用户从视图页面(v)发起一个请求到控制器(c)，控制器调用Service/Dao等处理数据， 并从数据库中返回数据(M)。之后控制器拿到数据后加以处理，并返回到视图页面。 实现方法： （1）ModelAndView：含Model和View两部分，数据将被放入request作用域 （2）ModelMap、Map及Model：不含view部分，可以方法的参数操作数据放入request作用域。 （3）@SessionAttribute：把数据放到session作用域 （4）@ModelAttribute：会在请求处理类中的每一个方法执行前都执行一次(谨用) ③视图、视图解析器(ViewResolver),以及对静态资源的处理 ④类型转换：将前端传来的数据类型转为请求处理方法参数中的所对应的类型 ⑤数据格式化、数据校验:让前端传入的数据按照一定格式、要求，否则报错。 ⑥文件上传、拦截器的使用。在springmvc.xml文件中配置： &lt;mvc:interceptors&gt; &lt;!-- 配置自定义的拦截器 --&gt; &lt;bean class=&quot;org.lanqiao.interceptor.FirstInterceptor&quot;&gt;&lt;/bean&gt; &lt;/mvc:interceptors&gt; ⑦异常处理：使用@ExceptionHandler注解用来捕获指定类型的异常。 ⑧SSM整合:Spring + springmvc + Mybatis Spring - Mybatis SqlSessionFactory - &gt; SqlSession -&gt; StduentMapper -&gt;CRUD 整合： 将SqlSessionFactory在spring中配置 Spring - SpringMvc：spring springmvc各自配置一遍 步骤： 1.jar包 2.Student 类 --Student表 3.(省略)--MyBatis配置SqlMapConfig.xml(数据源、 mapper.xml) 在spring配置文件中 applicationContext.xml 4.通过mapper.xml将 类、表建立映射关系 5.web配置spring springmvc 6.spring 整合mybatis 扫描器 7.spring整合springmvc(视图解析器 标准配置) ui层：前端（jsp）---&gt;通过注解调用 后端：SpringMvc（或Servlet） (controller控制器依赖于Service,即给controller注入service) Service层：StudentService.java StduentServiceImpl.java(依赖dao层，即给service注入mapper) &lt;!-- 配置DAO层:为StudentDaoImpl注入SqlSessionFactory对象 --&gt; &lt;bean id=&quot;studentService&quot; class=&quot;org.lanqiao.service.impl.StudentServiceImpl&quot;&gt; &lt;property name=&quot;studentDao&quot; ref=&quot;studentMapper&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;studentController&quot; class=&quot;org.lanqiao.controller.stduentController&quot;&gt; &lt;property name=&quot;studentService&quot; ref=&quot;studentService&quot;&gt;&lt;/property&gt; &lt;/bean&gt; dao层：studentMapper.java() StudentMapper.xml ---&gt;操作DB数据库 控制器 testController.java 业务逻辑层接口 testService.java 业务逻辑层实现类 testServiceImpl.java Web.xml中配置使用Spring和SpringMVC SpringMVC.xml配置扫描包、视图解析器和控制器Controller applicationContext.xml:配置数据库连接池、sqlSessionFactory、dao、service 编写test测试：jsp页面测试]]></content>
      <categories>
        <category>Web后端技术</category>
        <category>SSM框架--【SpringMVC学习】</category>
      </categories>
      <tags>
        <tag>框架学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM三大框架之---Spring]]></title>
    <url>%2F2019%2F05%2F12%2FWeb%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%2FSSM%E6%A1%86%E6%9E%B6-%E3%80%90Spring%E5%AD%A6%E4%B9%A0%E3%80%91%2Fssm%E4%B8%89%E5%A4%A7%E6%A1%86%E6%9E%B6%E4%B9%8B-spring%2F</url>
    <content type="text"><![CDATA[业务层框架Spring1.Spring程序开发的基本步骤:123456789101112131415161718192021222324251.准备好Spring开发的jar包，至少需要： spring-aop.jar 使用Spring的AOP特性时所需的jar类库 spring-beans.jar 包含访问配置文件、创建和管理bean 以及进行IoC/DI操作相关的所有类 spring-context.jar 为Spring核心提供了大量扩展。例如，可以找到使用Spring ApplicationContext 特性时所需的全部类，JDNI所需的全部类，以及校验Validation方面等相关类. spring-core.jar Spring框架的核心类库，Spring各个组件要都要使用到这个包里的类 spring-expression.jar Spring表达式语言需要的类库 可以下载第三方提供的日志jar commons-logging.jar，打印日志 2.开发工具：Eclipse+插件Spring Tool Suite，或者直接下载STS工具3.创建实体类、配置文件(applicationContext.xml)、编写测试类Test &lt;!-- 配置文件 applicationContext.xml，通过&lt;bean&gt;标签实现对象的赋值 --&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;唯一标识符&quot; class=&quot;包名+类名&quot;&gt; &lt;!-- 配置属性： value 值 -&gt; name 字段 --&gt; &lt;property name=&quot;属性&quot; value=&quot;属性值&quot;&gt;&lt;/property&gt; &lt;property name=&quot;属性名&quot; ref=&quot;引用对象的id值&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; 2.Spring的特点(获取对象不需要new，直接从IOC容器拿。前提是要在springIOC中存放对象并赋值)123456//1.创建Spring的IOC容器对象ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicatoinContext.xml&quot;);//2.从IOC容器中获取Bean实例(id为&quot;student&quot;的Student对象)//相当于 Student stu = new Student();Student stu =(Student)context.getBean(&quot;student&quot;);//继续操作 3.spring的学习内容12345678910111213141516171819202122232425262728293031323334353637383940414243444546 IOC(控制反转)：将创建对象、属性值的方式进行了翻转，从new、setXxx()翻转为 从SpringIOC 容器getBean()获取。 DI(依赖注入)：将属性值注入给属性，将属性注入给bean,将bean注入给IOC容器。 IOC容器赋值：基本类型 用 value=&quot; &quot;赋值；对象类型：ref =&quot; 需要引用的对象的id值 &quot;，实现对象与对象之间的依赖关系。 依赖注入的赋值方式： 1.setter注入((底层通过反射实现) 默认使用setter方法()给属性赋值 &lt;property&gt;标签 2.构造器注入：通过构造器注入 &lt;constructor-arg&gt;标签,其内部的属性赋值顺序需要和构造器参数的顺序一致； 如果不一致，则需要通过type、index或name指定顺序。 3.p命名空间注入：①引入命名空间：xmlns:p=&quot;http://www.springframework.org/schema/p&quot; ②&lt;bean&gt;标签里面添加：简单类型(8大类型+String)(p:属性名=&quot;属性值&quot;) 引用类型(p:属性名-ref=&quot;引用对象的id&quot;) ③ 注入各种集合数据类型(List、Set、Map、properties) 都有各自对应的标签使用 List或Array 外层用&lt;list&gt;；内层用&lt;value&gt;或&lt;ref&gt; Set 外层用&lt;set&gt;；内层用&lt;value&gt;或&lt;ref&gt; Map 外层用&lt;map&gt;；中间层用&lt;entry&gt;；内层中键用&lt;key&gt;&lt;value&gt;…&lt;/value&gt;&lt;/key&gt;， 值用&lt;value&gt;…&lt;/value&gt;或&lt;ref&gt;…&lt;/ref&gt; Properties 外层用&lt;props&gt;；内层中键写在&lt;prop key=”..”&gt;..&lt;/prop&gt;的key值中， 值写在&lt;prop&gt;..&lt;/prop&gt;中间。Properties中的键和值通常都是字符串类型。 自动装配： 自动装配 (只适用于ref类型) Course类中有一个ref属性propertyName（属性名），并且ioc容器中也有一个bean为的id也ropertyName autowire=&quot;byName&quot;：自动寻找其他bean的id值 = 该Course的属性名 autowire=&quot;byType&quot;：寻找其他bean的类型（class） = 该Course类的ref属性类型(只能有一个满足要求,否则报错) autowire=&quot;constructor&quot;：寻找其他bean的类型（class） = 该Course类的构造方法参数(本质和byType一样) &lt;bean id=&quot;Course&quot; class=&quot;包名+类名&quot; autowire=&quot;byName或者byType或constructor&quot;&gt; &lt;property name=&quot;...&quot; value=&quot;...&quot;&gt;&lt;/property&gt; &lt;!-- &lt;property name=&quot;...&quot; ref=&quot;...&quot;&gt;&lt;/property&gt; --&gt; &lt;/bean&gt; 注：&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; ... default-autowire=&quot;byName&quot;&gt; 可以一次性将该ioc容器中的所有bean统一设置成自动装配 注解定义bean:实体类添加注解，Spring在启动时，会根据base-package在改包中扫描所有类，查找这些类是否有注解。 如果有，则将该类加入spring ioc 容器。application.xml下添加： &lt;context:component-scan base-package=&quot;实体类所在包名&quot;&gt;&lt;/context:component-scan&gt; 常见注解(@Component)分为： dao层注解(@Repository)、service层注解(@Service)、控制器注解(@Controller) AOP(面向切面编程)：①前置通知 覆盖before()方法 目标方法执行前发生。 ②后置通知 覆盖afterReturning()方法 目标方法执行后发生 ③异常通知 无需覆盖方法 目标方法发生异常时执行 ④最终通知 目标方法执行完毕后,插入的通知（不论是正常返回还是异常退出）。 ④环绕通知 覆盖invoke()方法 拦截对目标方法调用，即调用目标方法的整个过程（功能最强大） Spring整合Mybatis:将Mybatis操作Dao层的权力交给Spring，Spring与其他什么框架整合的时候，权力全部 交由Spring掌控，Spring是老大。]]></content>
      <categories>
        <category>Web后端技术</category>
        <category>SSM框架--【Spring学习】</category>
      </categories>
      <tags>
        <tag>框架学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM三大框架之---MyBatis]]></title>
    <url>%2F2019%2F05%2F12%2FWeb%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%2FSSM%E6%A1%86%E6%9E%B6-%E3%80%90MyBatis%E5%AD%A6%E4%B9%A0%E3%80%91%2Fssm%E4%B8%89%E5%A4%A7%E6%A1%86%E6%9E%B6%E4%B9%8B-mybatis%2F</url>
    <content type="text"><![CDATA[持久层框架Mybatis1.MyBatis的基本步骤: 12341.mybatis.jar、mysql.jar(数据库连接包);2.conf.xml(数据库配置信息、映射文件)3.表-类：相对应的实体类(属性) 映射关系文件mapper.xml,mapper.java(包含方法的接口)4.编写测试类TestDemo 2.MyBatis的调用实现过程：123456789String resource = &quot;conf.xml&quot;;// 加载mybatis 的配置文件Reader reader = Resources.getResourceAsReader(resource);// 创建sqlSession 的工厂(由XML配置文件（conf.xml）创建SqlSessionFactory)SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader);// 通过SqlSessionFactory创建能够执行SQL映射文件中sql语句的sqlSession对象SqlSession session = sessionFactory.openSession(); //SqlSession对象包含了执行SQL所需要的所有方法，可以直接运行映射的SQL语句,完成对数据的增删改查等操作。 seesion.方法(); 3.MyBatis的学习内容1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374属性文件(db.properties) 全局参数：&lt;settings&gt;&lt;/settings&gt;里面的子标签设置 别名定义：不需要通过全类名的形式(即“包名+类名”),直接用包名访问 1.单个别名 &lt;typeAliases&gt; &lt;typeAlias type=&quot;实体类的对象类型&quot; alias=&quot;别名&quot;/&gt; &lt;/typeAliases&gt; 2.批量别名(包名下所有实体类都自动定义了别名) &lt;typeAliases&gt; &lt;package name=&quot;包名&quot;/&gt; &lt;/typeAliases&gt; 类型转换器：java类型与jdbc类型之间的映射(类型对应不上)，如javaType=&quot;java.lang.Boolean&quot; jdbcType=&quot;INTEGER&quot;，这时需自定义类型处理器，通过实现TypeHandler接口（或继承 BaseTypeHandler抽象类）取值符号： 1.#&#123;参数&#125;，可以防止SQL注入，并且会为传入String类型的参数值自动加上引号（参数名任意）， 但如果查询语句中传入一个int类型的值，则“#&#123;参数&#125;”不会为其加引号。 2.$&#123;value&#125;，来获取输入的参数值.这种方式不能防止SQL注意，有很大的安全隐患。 而且不会为字符串类型的值加上引号(需手动&quot;)，主要用于动态排序(order by). 输入参数(parameterType)：1.简单类型(8钟基本类型+String),输入参数名可任意 2.实体类的对象，要确保$&#123;&#125;或#&#123;&#125;中的参数名必须是实体类的属性名。 3.嵌套对象，A对象包含B对象的属性，可以#&#123;&#125;或$&#123;&#125;来获取传入的A对象的嵌套属性. 参数一般为A.B对象属性名。 4.HashMap:通过$&#123;&#125;或#&#123;&#125;获取key对应的value值。输出参数：1.简单类型，resultType=&quot; 简单类型 &quot; 2.HashMap。resultType=&quot;HashMap&quot; 3.resultMap.(用于处理字段名与属性名不一致) &lt;select&gt;元素中用resultMap的属性值匹配&lt;resultMap&gt; 元素的id值；然后在&lt;resultMap&gt;元素中用type指定相应&lt;select&gt;元素的返回值；并通过&lt;result&gt;子元素 的column指定字段名、property指定与字段名相对应的属性名，从而将字段名和属性名一一对应起来。 &lt;result&gt;元素用来指定普通字段，&lt;id&gt;元素用来指定主键字段。 注：亦可取通过别名形式字段名 &quot;属性名(字段名的别名)&quot;)处理字段名与属性名不一致的问题 动态SQL：MyBatis提供了&lt;if&gt;、&lt;where&gt;、&lt;foreach&gt;等标签来实现SQL语句的动态拼接。 关联查询：1.一对一 ① 业务扩展类(包含所要查询的表的所有属性) ② 使用resultMap实现一对一查询。表与表的外键在实体类使用成员变量表示在mapper.xml通过 &lt;association&gt;将属性与字段绑定起来 javaType=&quot;类型&quot; 2.一对多(多对一，多对多) 将查询的结果放在一个集合中&lt;collection&gt;标签进行字段与属性绑定 oftype=&quot;集合中的类型&quot; 日志输出：配置过程（导入log4j.jar） ① conf.xml文件配置 &lt;configuration&gt; &lt;properties resource=&quot;db.properties&quot; /&gt; &lt;settings&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt; &lt;/settings&gt; &lt;/configuration&gt; ② 编写log4j.properties log4j.rootLogger=DEBUG, stdout log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 延迟加载：根据需要延迟信息的加载，如一对多情况下，只想查看一的那部分，多的那部分延迟加载。配置加载方式： &lt;settings&gt; &lt;!-- 将延迟加载设置为：true （可省，因为默认值就是true）--&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt; &lt;!-- 将立即加载设置为：false --&gt; &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt; &lt;/settings&gt;缓存:一级缓存：同一个SqlSession对象共享。 第一次执行完查询时，向数据库发送语句，并将数据库的查询结果放入SQLSESSION内存（作为缓存），以后如果 再次执行该相同的查询SQL语句时，就会直接从内存中读取查询结果。 二级缓存：多个SqlSession对象共享的，范围是同一个namespace下SQL映射文件生成的动态代理mapper对象 *注：如果执行了增删改所需的commit()方法，那么SqlSession对象的一级缓存就会被清理（即将缓存中的数据 全部写入数据库，缓存变空）*逆向工程：在MyBatis的开发过程中，数据库表、实体类、SQL映射文件以及动态代理接口四者之间有着非常密切的关系。 只要根据一个，其余三个都能自动生成（依靠下载mybatis-generator-core-1.4.2-bundle.zip）。]]></content>
      <categories>
        <category>Web后端技术</category>
        <category>SSM框架--【MyBatis学习】</category>
      </categories>
      <tags>
        <tag>框架学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[滑动窗口的最大值]]></title>
    <url>%2F2019%2F04%2F23%2F%E5%88%B7%E9%A2%98%2Fnewcoder%2F%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%2F</url>
    <content type="text"><![CDATA[题目描述 给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。 题解 建立两个指针pLow(初始指向下标为0的位置),pHigh(指向size-1的地方)。以 pHigh &lt; num.length作为循环的条件，依次在list中add滑动窗口的最大值，然后使pLow++，pHigh++，直到循环推出。 代码123456789101112131415161718192021222324import java.util.ArrayList;public class WindowMove &#123; public ArrayList&lt;Integer&gt; maxInWindows(int[] num, int size) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); if (num == null || size &lt; 0) return null; if (size == 0) &#123; return list; &#125; int pLow = 0; int pHigh = pLow + size - 1; while (pHigh &lt; num.length) &#123; int max = 0; for (int i = pLow; i &lt;= pHigh; i++) &#123; if (max &lt; num[i]) max = num[i]; &#125; list.add(max); pLow++; pHigh++; &#125; return list; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
        <category>newcoder</category>
      </categories>
      <tags>
        <tag>nowcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[确定字符有无重复]]></title>
    <url>%2F2019%2F04%2F23%2F%E5%88%B7%E9%A2%98%2F%E7%A1%AE%E5%AE%9A%E5%AD%97%E7%AC%A6%E6%9C%89%E6%97%A0%E9%87%8D%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[题目描述 请实现一个算法，确定一个字符串的所有字符是否全都不同。给定一个string iniString，请返回一个bool值,True代表所有字符全都不同，False代表存在相同的字符。 代码12345678910111213141516171819202122import java.util.*;public class Different &#123; public boolean checkDifferent(String iniString) &#123; LinkedHashMap&lt;Character, Integer&gt; map = new LinkedHashMap&lt;Character, Integer&gt;(); char[] ch = iniString.toCharArray(); for (int i = 0; i &lt; ch.length; i++) &#123; if (map.containsKey(ch[i])) &#123; int time = map.get(ch[i]); map.put(ch[i], ++time); &#125; else map.put(ch[i], 1); &#125; for (int i = 0; i &lt; ch.length; i++) &#123; if (map.get(ch[i]) &gt; 1) return false; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>nowcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F15%2Funcategorized%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
