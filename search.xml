<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SSM三大框架之---MyBatis(1)]]></title>
    <url>%2F2019%2F04%2F21%2Fcjuse8a6k0000swvjiq18om53%2F</url>
    <content type="text"><![CDATA[SSM三大框架之—MyBatis(1)持久层框架Mybatis1.MyBatis的基本步骤: 12341.mybatis.jar、mysql.jar(数据库连接包);2.conf.xml(数据库配置信息、映射文件)3.表-类：相对应的实体类(属性) 映射关系文件mapper.xml,mapper.java(包含方法的接口)4.编写测试类TestDemo 2.MyBatis的调用实现过程：123456789String resource = &quot;conf.xml&quot;;// 加载mybatis 的配置文件Reader reader = Resources.getResourceAsReader(resource);// 创建sqlSession 的工厂(由XML配置文件（conf.xml）创建SqlSessionFactory)SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader);// 通过SqlSessionFactory创建能够执行SQL映射文件中sql语句的sqlSession对象SqlSession session = sessionFactory.openSession(); //SqlSession对象包含了执行SQL所需要的所有方法，可以直接运行映射的SQL语句,完成对数据的增删改查等操作。 seesion.方法(); 3.MyBatis的学习内容1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374属性文件(db.properties) 全局参数：&lt;settings&gt;&lt;/settings&gt;里面的子标签设置 别名定义：不需要通过全类名的形式(即“包名+类名”),直接用包名访问 1.单个别名 &lt;typeAliases&gt; &lt;typeAlias type=&quot;实体类的对象类型&quot; alias=&quot;别名&quot;/&gt; &lt;/typeAliases&gt; 2.批量别名(包名下所有实体类都自动定义了别名) &lt;typeAliases&gt; &lt;package name=&quot;包名&quot;/&gt; &lt;/typeAliases&gt; 类型转换器：java类型与jdbc类型之间的映射(类型对应不上)，如javaType=&quot;java.lang.Boolean&quot; jdbcType=&quot;INTEGER&quot;，这时需自定义类型处理器，通过实现TypeHandler接口（或继承 BaseTypeHandler抽象类）取值符号： 1.#&#123;参数&#125;，可以防止SQL注入，并且会为传入String类型的参数值自动加上引号（参数名任意）， 但如果查询语句中传入一个int类型的值，则“#&#123;参数&#125;”不会为其加引号。 2.$&#123;value&#125;，来获取输入的参数值.这种方式不能防止SQL注意，有很大的安全隐患。 而且不会为字符串类型的值加上引号(需手动&quot;)，主要用于动态排序(order by). 输入参数(parameterType)：1.简单类型(8钟基本类型+String),输入参数名可任意 2.实体类的对象，要确保$&#123;&#125;或#&#123;&#125;中的参数名必须是实体类的属性名。 3.嵌套对象，A对象包含B对象的属性，可以#&#123;&#125;或$&#123;&#125;来获取传入的A对象的嵌套属性. 参数一般为A.B对象属性名。 4.HashMap:通过$&#123;&#125;或#&#123;&#125;获取key对应的value值。输出参数：1.简单类型，resultType=&quot; 简单类型 &quot; 2.HashMap。resultType=&quot;HashMap&quot; 3.resultMap.(用于处理字段名与属性名不一致) &lt;select&gt;元素中用resultMap的属性值匹配&lt;resultMap&gt; 元素的id值；然后在&lt;resultMap&gt;元素中用type指定相应&lt;select&gt;元素的返回值；并通过&lt;result&gt;子元素 的column指定字段名、property指定与字段名相对应的属性名，从而将字段名和属性名一一对应起来。 &lt;result&gt;元素用来指定普通字段，&lt;id&gt;元素用来指定主键字段。 注：亦可取通过别名形式字段名 &quot;属性名(字段名的别名)&quot;)处理字段名与属性名不一致的问题 动态SQL：MyBatis提供了&lt;if&gt;、&lt;where&gt;、&lt;foreach&gt;等标签来实现SQL语句的动态拼接。 关联查询：1.一对一 ① 业务扩展类(包含所要查询的表的所有属性) ② 使用resultMap实现一对一查询。表与表的外键在实体类使用成员变量表示在mapper.xml通过 &lt;association&gt;将属性与字段绑定起来 javaType=&quot;类型&quot; 2.一对多(多对一，多对多) 将查询的结果放在一个集合中&lt;collection&gt;标签进行字段与属性绑定 oftype=&quot;集合中的类型&quot; 日志输出：配置过程（导入log4j.jar） ① conf.xml文件配置 &lt;configuration&gt; &lt;properties resource=&quot;db.properties&quot; /&gt; &lt;settings&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt; &lt;/settings&gt; &lt;/configuration&gt; ② 编写log4j.properties log4j.rootLogger=DEBUG, stdout log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 延迟加载：根据需要延迟信息的加载，如一对多情况下，只想查看一的那部分，多的那部分延迟加载。配置加载方式： &lt;settings&gt; &lt;!-- 将延迟加载设置为：true （可省，因为默认值就是true）--&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt; &lt;!-- 将立即加载设置为：false --&gt; &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt; &lt;/settings&gt;缓存:一级缓存：同一个SqlSession对象共享。 第一次执行完查询时，向数据库发送语句，并将数据库的查询结果放入SQLSESSION内存（作为缓存），以后如果 再次执行该相同的查询SQL语句时，就会直接从内存中读取查询结果。 二级缓存：多个SqlSession对象共享的，范围是同一个namespace下SQL映射文件生成的动态代理mapper对象 *注：如果执行了增删改所需的commit()方法，那么SqlSession对象的一级缓存就会被清理（即将缓存中的数据 全部写入数据库，缓存变空）*逆向工程：在MyBatis的开发过程中，数据库表、实体类、SQL映射文件以及动态代理接口四者之间有着非常密切的关系。 只要根据一个，其余三个都能自动生成（依靠下载mybatis-generator-core-1.4.2-bundle.zip）。]]></content>
      <tags>
        <tag>框架学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F15%2Fcjuse8a6t0002swvju31nyhmy%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
