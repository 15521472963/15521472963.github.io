<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MySQL基础笔记（2）-- SQL语言]]></title>
    <url>%2F2019%2F05%2F14%2FJavaWeb%2F%E3%80%90MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%91%2Fmysql%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89-sql%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[什么是SQL查询语言？SQL是Structured Quevy Language(结构化查询语言)的缩写。 SQL是专为数据库而建立的操作命令集，是一种功能齐全的数据库语言。在使用它时，只需要 发出“做什么”的命令，“怎么做”是不用使用者考虑的。 SQL数据类型1.常用的数据类型double：浮点型，例如double(5,2)表示最多5位，其中必须有2位小数，即最大值为999.99； char：固定长度字符串类型； char(10) &apos;abc&apos; varchar：可变长度字符串类型；varchar(10) &apos;abc&apos; text：字符串类型; blob：二进制类型； date：日期类型，格式为：yyyy-MM-dd； time：时间类型，格式为：hh:mm:ss datetime:日期时间类型 yyyy-MM-dd hh:mm:ss 在mysql中，字符串类型和日期类型都要用单引号括起来。 如’sql_study’、’2020-01-01’等 MySQL支持的数据类型大致可以分为三类1.数值类型 2.字符串类型 3.日期和时间类型 sql功能分类1.DDL: 数据定义语言DDL是用来定义数据库对象：创建库，表，列等。 创建数据库 create database 数据库名 character set utf8; 修改数据库 alter database 数据库名 charactor set gbk; 查看表的字段信息 DESC 表名; 查看表的创建细节 SHOW CREATE TABLE 表名; 修改表的字符集为gbk ALTER TABLE 表名 CHARACTER SET 字符集名称; 创建表 create table 表名(列名1 列的类型[约束]，列名2 列的类型[约束]....); 修改表名 RENAME TABLE 原始表名 TO 要修改的表名; 修改一个表的字段类型 ALTER TABLE 表名 MODIFY 字段名 数据类型 修改表的列名 ALTER TABLE 表名 CHANGE 原始列名 新列名 数据类型; 删除表 DROP TABLE 表名; 添加一列 ALTER TABLE 表名 ADD 列名 数据类型; 删除一列 ALTER TABLE 表名 DROP 字段名; 2.DML：数据操作语言DML用来操作数据库表中的记录，即就是对数据库的数据进行增删改查的操作 ①查询操作 查询表中的所有数据 SELECT * FROM 表名; 查询表中的指定数据 SELECT * FROM 表名 where 条件; ②插入操作 单个数据插入 INSERT INTO 表名（列名1，列名2 ...）VALUE (列值1，列值2...); 批量数据插入 INSERT INTO 表名（列名1，列名2 ...）VALUES (列值1，列值2...)，(列值1，列值2...); ③更新操作 更新记录 UPDATE 表名 SET 列名1=列值1，列名2=列值2 .... WHERE 列名=值; ④删除操作 删除记录 DELETE FROM 表名 【WHERE 列名=值】; (DELETE 删除表中的数据，表结构还在;删除后的数据可以找回) 删除所有记录 TRUNCATE TABLE 表名; (删除是把表直接DROP掉，然后再创建一个同样的新表。删除的数据不能找回) 3.DQL：数据查询语言DQL用来查询数据。数据库执行DQL语句不会对数据进行改变，而是让数据库发送结果集给客户端。 结果集：通过查询语句查询出来的数据以表的形式展示我们称这个表为虚拟结果集，并存放在内存中。查询返回 的结果集是一张虚拟表。 DQL包含模糊查询、条件查询、字段控制查询、排序、以及聚合函数的应用 4.DCL：数据控制语言DCL用来定义访问权限和安全级别。即对数据库事务（trasaction）的控制，包括事务的提交（commit），事务的回滚（rollback），以及权限的管理等。]]></content>
      <categories>
        <category>JavaWeb</category>
        <category>【MySQL数据库】</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL基础笔记（1）-- 数据库的介绍]]></title>
    <url>%2F2019%2F05%2F13%2FJavaWeb%2F%E3%80%90MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%91%2Fmysql%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[什么是数据库？数据库是是按照数据结构来组织、存储和管理数据的仓库。我们一般说的数据库,就是指的DBMS: 数据库服务器（是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，简称DBMS）.常见的数据库有Oracle、MySQL、SQL Server等等. Oracle: 运行稳定，可移植性高，功能齐全，性能超群！适用于大型企业领域。MySQL:开源，体积小，速度快。适用于于中小型企业领域。SQL Server: 全面，效率高，界面友好，操作容易，但是不跨平台。适用于于中小型企业领域。 数据库系统的专业术语表 具有固定的列数,和任意的行数 数据库 数据库是一些关联表的集合 列 一个数据项 Field 字段 行 一条记录（row） 主键 主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。 外键 外键用于关联两个表 索引 使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。 类似于书籍的目录。 MySQL数据库1.MySql介绍 MySQL是一个关系型数据库管理系统，属于Oracle公司。MySQL是一种关联数据库管理系统，关联数据库将数据保 存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。Mysql是开源的,而且支持 大型的数据库。可以处理拥有上千万条记录的大型数据库。 MySQL使用标准的SQL数据语言形式。 Mysql可以允许于多个系统上，并且支持多种语言。这些编程语言包括C、C++、Python、Java等。 2.MySql安装 (下载地址 https://dev.mysql.com/downloads/mysql/)3.MySql的存储引擎① 什么是存储引擎 MySQL中的数据用各种不同的技术存储在文件（或者内存）中。这些技术中的每一种技术都使用不同的存储机 制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。通过选择不同的技术，你能够获得额外的速度或 者功能，从而改善你的应用的整体功能。（不同的存储引擎性能是不一样的） ②什么是事务 是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。 4.存储引擎分类MYISAM ：它不支持事务，也不支持外键，尤其是访问速度快，对事务完整性没有要求或者以SELECT、INSERT为主的应 用基本都可以使用这个引擎来创建表。每个MyISAM在磁盘上存储成3个文件，其中文件名和表名都相同，但 是扩展名分别为：.frm(存储表定义)、MYD(MYData，存储数据)、MYI(MYIndex，存储索引) INNODB：InnoDB存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是对比MyISAM的存储引擎，InnoDB写的 处理效率差一些并且会占用更多的磁盘空间以保留数据和索引。 MEMORY：memory使用存在内存中的内容来创建表。每个MEMORY表实际对应一个磁盘文件，格式是.frm。 MEMORY类型的表访问非常快，因为它到数据是放在内存中的，并且默认使用HASH索引，但是一旦服务器关闭， 表中的数据就会丢失，但表还会继续存在。 常用数据库命令1.Mysql数据库的分类 (1)系统数据库 information_schema 存储数据库对象信息如用户表信息,列信息,根除,字符,分区里面的内容我们不能动. performance_schema 存储数据库服务器性能参数信息 mysql 存储数据库用户权限信息 sys 通过这个库可以快速的了解系统的元数据信息（这个库是通过视图的形式把information_schema 和 performance_schema结合起来，查询出更加令人容易理解的数据 (2)用户数据库 用户自己创建的数据库,一个项目用一个数据库 2.Mysql数据库命令]]></content>
      <categories>
        <category>JavaWeb</category>
        <category>【MySQL数据库】</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM三大框架之---SpringMVC]]></title>
    <url>%2F2019%2F05%2F12%2FWeb%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%2FSSM%E6%A1%86%E6%9E%B6-%E3%80%90SpringMVC%E5%AD%A6%E4%B9%A0%E3%80%91%2Fssm%E4%B8%89%E5%A4%A7%E6%A1%86%E6%9E%B6%E4%B9%8B-springmvc%2F</url>
    <content type="text"><![CDATA[表现层框架SpringMVC1.SpringMVC程序开发的基本步骤:123456789101112131415161718192021221.准备好SpringMVC开发的jar包(8个) spring-aop.jar spring-beans.jar spring-context.jar spring-core.jar spring-expression.jar commons-logging.jar spring-web.jar 在Web应用开发过程中，用到Spring框架时所需的核心类库 spring-webmvc.jar Spring MVC框架相关的所有类。如国际化、标签、Theme、FreeMarker等相关类2.在web.xml中配置前置控制器DispatcherServlet，用于拦截与&lt;url-pattern&gt;相匹配的请求 3.开发前端请求页面(index.jsp) 4.开发请求处理类(controller）：含注解@Controller、@RequestMapping()等5.在src目录下创建SpringMVC的配置文件：springmvc.xml &lt;!-- 配置需要扫描的包 --&gt; &lt;context:component-scan base-package=&quot;com.YYcoder.controller&quot;&gt; &lt;/context:component-scan&gt; &lt;!-- 配置视图解析器：把请求处理类的返回值，加工成最终的视图路径--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/views/&quot;&gt;&lt;/property&gt;&lt;!--前缀--&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;&lt;!--后缀--&gt; &lt;/bean&gt;6.开发前端结果显示页面：result.jsp 2.SpringMVC的学习内容(主要是学会如何使用注解来实现操作) ①常见注解的使用(可以参考springMVC的文档学习) @RequestMapping 用来给方法绑定一个请求映射 @PathVariable 获取动态参数 @RequestParam 获取请求参数 @RequestHeader 获取请求中的“头信息” @CookieValue 可以给处理方法入参绑定某个Cookie值 ②处理模型数据：用户从视图页面(v)发起一个请求到控制器(c)，控制器调用Service/Dao等处理数据， 并从数据库中返回数据(M)。之后控制器拿到数据后加以处理，并返回到视图页面。 实现方法： （1）ModelAndView：含Model和View两部分，数据将被放入request作用域 （2）ModelMap、Map及Model：不含view部分，可以方法的参数操作数据放入request作用域。 （3）@SessionAttribute：把数据放到session作用域 （4）@ModelAttribute：会在请求处理类中的每一个方法执行前都执行一次(谨用) ③视图、视图解析器(ViewResolver),以及对静态资源的处理 ④类型转换：将前端传来的数据类型转为请求处理方法参数中的所对应的类型 ⑤数据格式化、数据校验:让前端传入的数据按照一定格式、要求，否则报错。 ⑥文件上传、拦截器的使用。在springmvc.xml文件中配置： &lt;mvc:interceptors&gt; &lt;!-- 配置自定义的拦截器 --&gt; &lt;bean class=&quot;org.lanqiao.interceptor.FirstInterceptor&quot;&gt;&lt;/bean&gt; &lt;/mvc:interceptors&gt; ⑦异常处理：使用@ExceptionHandler注解用来捕获指定类型的异常。 ⑧SSM整合:Spring + springmvc + Mybatis Spring - Mybatis SqlSessionFactory - &gt; SqlSession -&gt; StduentMapper -&gt;CRUD 整合： 将SqlSessionFactory在spring中配置 Spring - SpringMvc：spring springmvc各自配置一遍 步骤： 1.jar包 2.Student 类 --Student表 3.(省略)--MyBatis配置SqlMapConfig.xml(数据源、 mapper.xml) 在spring配置文件中 applicationContext.xml 4.通过mapper.xml将 类、表建立映射关系 5.web配置spring springmvc 6.spring 整合mybatis 扫描器 7.spring整合springmvc(视图解析器 标准配置) ui层：前端（jsp）---&gt;通过注解调用 后端：SpringMvc（或Servlet） (controller控制器依赖于Service,即给controller注入service) Service层：StudentService.java StduentServiceImpl.java(依赖dao层，即给service注入mapper) &lt;!-- 配置DAO层:为StudentDaoImpl注入SqlSessionFactory对象 --&gt; &lt;bean id=&quot;studentService&quot; class=&quot;org.lanqiao.service.impl.StudentServiceImpl&quot;&gt; &lt;property name=&quot;studentDao&quot; ref=&quot;studentMapper&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;studentController&quot; class=&quot;org.lanqiao.controller.stduentController&quot;&gt; &lt;property name=&quot;studentService&quot; ref=&quot;studentService&quot;&gt;&lt;/property&gt; &lt;/bean&gt; dao层：studentMapper.java() StudentMapper.xml ---&gt;操作DB数据库 控制器 testController.java 业务逻辑层接口 testService.java 业务逻辑层实现类 testServiceImpl.java Web.xml中配置使用Spring和SpringMVC SpringMVC.xml配置扫描包、视图解析器和控制器Controller applicationContext.xml:配置数据库连接池、sqlSessionFactory、dao、service 编写test测试：jsp页面测试]]></content>
      <categories>
        <category>Web后端技术</category>
        <category>SSM框架--【SpringMVC学习】</category>
      </categories>
      <tags>
        <tag>框架学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM三大框架之---Spring]]></title>
    <url>%2F2019%2F05%2F12%2FWeb%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%2FSSM%E6%A1%86%E6%9E%B6-%E3%80%90Spring%E5%AD%A6%E4%B9%A0%E3%80%91%2Fssm%E4%B8%89%E5%A4%A7%E6%A1%86%E6%9E%B6%E4%B9%8B-spring%2F</url>
    <content type="text"><![CDATA[业务层框架Spring1.Spring程序开发的基本步骤:123456789101112131415161718192021222324251.准备好Spring开发的jar包，至少需要： spring-aop.jar 使用Spring的AOP特性时所需的jar类库 spring-beans.jar 包含访问配置文件、创建和管理bean 以及进行IoC/DI操作相关的所有类 spring-context.jar 为Spring核心提供了大量扩展。例如，可以找到使用Spring ApplicationContext 特性时所需的全部类，JDNI所需的全部类，以及校验Validation方面等相关类. spring-core.jar Spring框架的核心类库，Spring各个组件要都要使用到这个包里的类 spring-expression.jar Spring表达式语言需要的类库 可以下载第三方提供的日志jar commons-logging.jar，打印日志 2.开发工具：Eclipse+插件Spring Tool Suite，或者直接下载STS工具3.创建实体类、配置文件(applicationContext.xml)、编写测试类Test &lt;!-- 配置文件 applicationContext.xml，通过&lt;bean&gt;标签实现对象的赋值 --&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;唯一标识符&quot; class=&quot;包名+类名&quot;&gt; &lt;!-- 配置属性： value 值 -&gt; name 字段 --&gt; &lt;property name=&quot;属性&quot; value=&quot;属性值&quot;&gt;&lt;/property&gt; &lt;property name=&quot;属性名&quot; ref=&quot;引用对象的id值&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; 2.Spring的特点(获取对象不需要new，直接从IOC容器拿。前提是要在springIOC中存放对象并赋值)123456//1.创建Spring的IOC容器对象ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicatoinContext.xml&quot;);//2.从IOC容器中获取Bean实例(id为&quot;student&quot;的Student对象)//相当于 Student stu = new Student();Student stu =(Student)context.getBean(&quot;student&quot;);//继续操作 3.spring的学习内容12345678910111213141516171819202122232425262728293031323334353637383940414243444546 IOC(控制反转)：将创建对象、属性值的方式进行了翻转，从new、setXxx()翻转为 从SpringIOC 容器getBean()获取。 DI(依赖注入)：将属性值注入给属性，将属性注入给bean,将bean注入给IOC容器。 IOC容器赋值：基本类型 用 value=&quot; &quot;赋值；对象类型：ref =&quot; 需要引用的对象的id值 &quot;，实现对象与对象之间的依赖关系。 依赖注入的赋值方式： 1.setter注入((底层通过反射实现) 默认使用setter方法()给属性赋值 &lt;property&gt;标签 2.构造器注入：通过构造器注入 &lt;constructor-arg&gt;标签,其内部的属性赋值顺序需要和构造器参数的顺序一致； 如果不一致，则需要通过type、index或name指定顺序。 3.p命名空间注入：①引入命名空间：xmlns:p=&quot;http://www.springframework.org/schema/p&quot; ②&lt;bean&gt;标签里面添加：简单类型(8大类型+String)(p:属性名=&quot;属性值&quot;) 引用类型(p:属性名-ref=&quot;引用对象的id&quot;) ③ 注入各种集合数据类型(List、Set、Map、properties) 都有各自对应的标签使用 List或Array 外层用&lt;list&gt;；内层用&lt;value&gt;或&lt;ref&gt; Set 外层用&lt;set&gt;；内层用&lt;value&gt;或&lt;ref&gt; Map 外层用&lt;map&gt;；中间层用&lt;entry&gt;；内层中键用&lt;key&gt;&lt;value&gt;…&lt;/value&gt;&lt;/key&gt;， 值用&lt;value&gt;…&lt;/value&gt;或&lt;ref&gt;…&lt;/ref&gt; Properties 外层用&lt;props&gt;；内层中键写在&lt;prop key=”..”&gt;..&lt;/prop&gt;的key值中， 值写在&lt;prop&gt;..&lt;/prop&gt;中间。Properties中的键和值通常都是字符串类型。 自动装配： 自动装配 (只适用于ref类型) Course类中有一个ref属性propertyName（属性名），并且ioc容器中也有一个bean为的id也ropertyName autowire=&quot;byName&quot;：自动寻找其他bean的id值 = 该Course的属性名 autowire=&quot;byType&quot;：寻找其他bean的类型（class） = 该Course类的ref属性类型(只能有一个满足要求,否则报错) autowire=&quot;constructor&quot;：寻找其他bean的类型（class） = 该Course类的构造方法参数(本质和byType一样) &lt;bean id=&quot;Course&quot; class=&quot;包名+类名&quot; autowire=&quot;byName或者byType或constructor&quot;&gt; &lt;property name=&quot;...&quot; value=&quot;...&quot;&gt;&lt;/property&gt; &lt;!-- &lt;property name=&quot;...&quot; ref=&quot;...&quot;&gt;&lt;/property&gt; --&gt; &lt;/bean&gt; 注：&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; ... default-autowire=&quot;byName&quot;&gt; 可以一次性将该ioc容器中的所有bean统一设置成自动装配 注解定义bean:实体类添加注解，Spring在启动时，会根据base-package在改包中扫描所有类，查找这些类是否有注解。 如果有，则将该类加入spring ioc 容器。application.xml下添加： &lt;context:component-scan base-package=&quot;实体类所在包名&quot;&gt;&lt;/context:component-scan&gt; 常见注解(@Component)分为： dao层注解(@Repository)、service层注解(@Service)、控制器注解(@Controller) AOP(面向切面编程)：①前置通知 覆盖before()方法 目标方法执行前发生。 ②后置通知 覆盖afterReturning()方法 目标方法执行后发生 ③异常通知 无需覆盖方法 目标方法发生异常时执行 ④最终通知 目标方法执行完毕后,插入的通知（不论是正常返回还是异常退出）。 ④环绕通知 覆盖invoke()方法 拦截对目标方法调用，即调用目标方法的整个过程（功能最强大） Spring整合Mybatis:将Mybatis操作Dao层的权力交给Spring，Spring与其他什么框架整合的时候，权力全部 交由Spring掌控，Spring是老大。]]></content>
      <categories>
        <category>Web后端技术</category>
        <category>SSM框架--【Spring学习】</category>
      </categories>
      <tags>
        <tag>框架学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM三大框架之---MyBatis]]></title>
    <url>%2F2019%2F05%2F12%2FWeb%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%2FSSM%E6%A1%86%E6%9E%B6-%E3%80%90MyBatis%E5%AD%A6%E4%B9%A0%E3%80%91%2Fssm%E4%B8%89%E5%A4%A7%E6%A1%86%E6%9E%B6%E4%B9%8B-mybatis%2F</url>
    <content type="text"><![CDATA[持久层框架Mybatis1.MyBatis的基本步骤: 12341.mybatis.jar、mysql.jar(数据库连接包);2.conf.xml(数据库配置信息、映射文件)3.表-类：相对应的实体类(属性) 映射关系文件mapper.xml,mapper.java(包含方法的接口)4.编写测试类TestDemo 2.MyBatis的调用实现过程：123456789String resource = &quot;conf.xml&quot;;// 加载mybatis 的配置文件Reader reader = Resources.getResourceAsReader(resource);// 创建sqlSession 的工厂(由XML配置文件（conf.xml）创建SqlSessionFactory)SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader);// 通过SqlSessionFactory创建能够执行SQL映射文件中sql语句的sqlSession对象SqlSession session = sessionFactory.openSession(); //SqlSession对象包含了执行SQL所需要的所有方法，可以直接运行映射的SQL语句,完成对数据的增删改查等操作。 seesion.方法(); 3.MyBatis的学习内容1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374属性文件(db.properties) 全局参数：&lt;settings&gt;&lt;/settings&gt;里面的子标签设置 别名定义：不需要通过全类名的形式(即“包名+类名”),直接用包名访问 1.单个别名 &lt;typeAliases&gt; &lt;typeAlias type=&quot;实体类的对象类型&quot; alias=&quot;别名&quot;/&gt; &lt;/typeAliases&gt; 2.批量别名(包名下所有实体类都自动定义了别名) &lt;typeAliases&gt; &lt;package name=&quot;包名&quot;/&gt; &lt;/typeAliases&gt; 类型转换器：java类型与jdbc类型之间的映射(类型对应不上)，如javaType=&quot;java.lang.Boolean&quot; jdbcType=&quot;INTEGER&quot;，这时需自定义类型处理器，通过实现TypeHandler接口（或继承 BaseTypeHandler抽象类）取值符号： 1.#&#123;参数&#125;，可以防止SQL注入，并且会为传入String类型的参数值自动加上引号（参数名任意）， 但如果查询语句中传入一个int类型的值，则“#&#123;参数&#125;”不会为其加引号。 2.$&#123;value&#125;，来获取输入的参数值.这种方式不能防止SQL注意，有很大的安全隐患。 而且不会为字符串类型的值加上引号(需手动&quot;)，主要用于动态排序(order by). 输入参数(parameterType)：1.简单类型(8钟基本类型+String),输入参数名可任意 2.实体类的对象，要确保$&#123;&#125;或#&#123;&#125;中的参数名必须是实体类的属性名。 3.嵌套对象，A对象包含B对象的属性，可以#&#123;&#125;或$&#123;&#125;来获取传入的A对象的嵌套属性. 参数一般为A.B对象属性名。 4.HashMap:通过$&#123;&#125;或#&#123;&#125;获取key对应的value值。输出参数：1.简单类型，resultType=&quot; 简单类型 &quot; 2.HashMap。resultType=&quot;HashMap&quot; 3.resultMap.(用于处理字段名与属性名不一致) &lt;select&gt;元素中用resultMap的属性值匹配&lt;resultMap&gt; 元素的id值；然后在&lt;resultMap&gt;元素中用type指定相应&lt;select&gt;元素的返回值；并通过&lt;result&gt;子元素 的column指定字段名、property指定与字段名相对应的属性名，从而将字段名和属性名一一对应起来。 &lt;result&gt;元素用来指定普通字段，&lt;id&gt;元素用来指定主键字段。 注：亦可取通过别名形式字段名 &quot;属性名(字段名的别名)&quot;)处理字段名与属性名不一致的问题 动态SQL：MyBatis提供了&lt;if&gt;、&lt;where&gt;、&lt;foreach&gt;等标签来实现SQL语句的动态拼接。 关联查询：1.一对一 ① 业务扩展类(包含所要查询的表的所有属性) ② 使用resultMap实现一对一查询。表与表的外键在实体类使用成员变量表示在mapper.xml通过 &lt;association&gt;将属性与字段绑定起来 javaType=&quot;类型&quot; 2.一对多(多对一，多对多) 将查询的结果放在一个集合中&lt;collection&gt;标签进行字段与属性绑定 oftype=&quot;集合中的类型&quot; 日志输出：配置过程（导入log4j.jar） ① conf.xml文件配置 &lt;configuration&gt; &lt;properties resource=&quot;db.properties&quot; /&gt; &lt;settings&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt; &lt;/settings&gt; &lt;/configuration&gt; ② 编写log4j.properties log4j.rootLogger=DEBUG, stdout log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 延迟加载：根据需要延迟信息的加载，如一对多情况下，只想查看一的那部分，多的那部分延迟加载。配置加载方式： &lt;settings&gt; &lt;!-- 将延迟加载设置为：true （可省，因为默认值就是true）--&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt; &lt;!-- 将立即加载设置为：false --&gt; &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt; &lt;/settings&gt;缓存:一级缓存：同一个SqlSession对象共享。 第一次执行完查询时，向数据库发送语句，并将数据库的查询结果放入SQLSESSION内存（作为缓存），以后如果 再次执行该相同的查询SQL语句时，就会直接从内存中读取查询结果。 二级缓存：多个SqlSession对象共享的，范围是同一个namespace下SQL映射文件生成的动态代理mapper对象 *注：如果执行了增删改所需的commit()方法，那么SqlSession对象的一级缓存就会被清理（即将缓存中的数据 全部写入数据库，缓存变空）*逆向工程：在MyBatis的开发过程中，数据库表、实体类、SQL映射文件以及动态代理接口四者之间有着非常密切的关系。 只要根据一个，其余三个都能自动生成（依靠下载mybatis-generator-core-1.4.2-bundle.zip）。]]></content>
      <categories>
        <category>Web后端技术</category>
        <category>SSM框架--【MyBatis学习】</category>
      </categories>
      <tags>
        <tag>框架学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[滑动窗口的最大值]]></title>
    <url>%2F2019%2F04%2F23%2F%E5%88%B7%E9%A2%98%2Fnewcoder%2F%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%2F</url>
    <content type="text"><![CDATA[题目描述 给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。 题解 建立两个指针pLow(初始指向下标为0的位置),pHigh(指向size-1的地方)。以 pHigh &lt; num.length作为循环的条件，依次在list中add滑动窗口的最大值，然后使pLow++，pHigh++，直到循环推出。 代码123456789101112131415161718192021222324import java.util.ArrayList;public class WindowMove &#123; public ArrayList&lt;Integer&gt; maxInWindows(int[] num, int size) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); if (num == null || size &lt; 0) return null; if (size == 0) &#123; return list; &#125; int pLow = 0; int pHigh = pLow + size - 1; while (pHigh &lt; num.length) &#123; int max = 0; for (int i = pLow; i &lt;= pHigh; i++) &#123; if (max &lt; num[i]) max = num[i]; &#125; list.add(max); pLow++; pHigh++; &#125; return list; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
        <category>newcoder</category>
      </categories>
      <tags>
        <tag>nowcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[确定字符有无重复]]></title>
    <url>%2F2019%2F04%2F23%2F%E5%88%B7%E9%A2%98%2F%E7%A1%AE%E5%AE%9A%E5%AD%97%E7%AC%A6%E6%9C%89%E6%97%A0%E9%87%8D%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[题目描述 请实现一个算法，确定一个字符串的所有字符是否全都不同。给定一个string iniString，请返回一个bool值,True代表所有字符全都不同，False代表存在相同的字符。 代码12345678910111213141516171819202122import java.util.*;public class Different &#123; public boolean checkDifferent(String iniString) &#123; LinkedHashMap&lt;Character, Integer&gt; map = new LinkedHashMap&lt;Character, Integer&gt;(); char[] ch = iniString.toCharArray(); for (int i = 0; i &lt; ch.length; i++) &#123; if (map.containsKey(ch[i])) &#123; int time = map.get(ch[i]); map.put(ch[i], ++time); &#125; else map.put(ch[i], 1); &#125; for (int i = 0; i &lt; ch.length; i++) &#123; if (map.get(ch[i]) &gt; 1) return false; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>nowcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F15%2Funcategorized%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
