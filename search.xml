<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2020%2F02%2F10%2Funcategorized%2F%2F</url>
    <content type="text"><![CDATA[annotation 注解（public @interface 类名{}）]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F02%2F10%2Funcategorized%2F%2F</url>
    <content type="text"><![CDATA[springbean的生命周期 springbeadn的初始化实例 beanDefinitionspring 工厂spring 容器 spring 上下文 spring很多组件围绕一起形成正常工作的环境.为了配合Ioc和Aop spring和主流框架的与源码 设计模式：代理模式、工厂模式（隐藏复杂的逻辑过程，只关心结果）简单工厂、工厂抽象工厂 单例模式：保证从系统启动到系统停止，全过程只会产生一个实例 配置文件、直接上级领导、 Spring IOC Spring Aoc在spring Framework广泛应用features:特性 Ioc 只需要一个SpringMvc就行了Aop 面向切面 cglibrefrensh() 调用12个方法sync: prepareRefresh(); 准备工作包括设置启动时间，是否激活标识位。初始化属性源（property source）配置 ConfigurableListableBeanFactory beanFactory=obtainFreshBeanFactory()l prepareBeanFactory(beanFactory); postProcessBeanFactory(beanFactory) 整个方法在当前5.0.x版本中没有任何代码，可能期待后面的扩展把 invokeBeanFactoryPostProcessors(beanFactory) 扫描包scan - put map -执行BeanFactory 在spring环境中执行已被注册的factory processors,设置执行实现了BeanFactoryPostProcessor自定义的ProcessBeanFactory【重写postProcessBeanFactory方法，用个BeanDefinition的子类GenericBeanDefinition接收beanFactory.getBeanDefinition(beanName)】和spring内部自己定义的。 registerBeanPostProcessors() 注册beanPostProcessor initMessageSource(); initApplicationEventMulticaster(); 初始化应用事件广播器 onRefresh() registerListeners(); finishBeanFactoryInitialzation finishRefresh(); BeanFactory]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F02%2F09%2Funcategorized%2F%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F02%2F08%2Funcategorized%2F%2F</url>
    <content type="text"><![CDATA[在方法同步时，加重量锁Synchronized进行同步，但没有使用到的话又会浪费空间，不加的话又可能会失去线程安全线程执行的模式有两种①交替执行 1.6之前 sync都会调用操作系统函数去解决我们线程的同步问题 reentrantLock在jdk级别就解决了 1.6之后 sync也在jdk级别解决了 reentrantLock 单个线程-交替执行 其实是与队列无关 jdk级别解决线程同步问题 AQS和reentrantLock 使用 自旋 park CAS实现 整个Aqs队列里面的队首的thread永远为空 精髓持有锁的线程不在队列中]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F02%2F07%2Funcategorized%2F%2F</url>
    <content type="text"><![CDATA[一、使用线程实现 Runnable 接口实现 Callable 接口继承 Thread 类实现接口 VS 继承 Thread二、基础线程机制ExecutorDaemonsleep()yield()三、中断InterruptedExceptioninterrupted()Executor 的中断操作四、互斥同步synchronizedReentrantLock比较使用选择五、线程之间的协作join()wait() notify() notifyAll()await() signal() signalAll()六、线程状态新建（NEW）可运行（RUNABLE）阻塞（BLOCKED）无限期等待（WAITING）限期等待（TIMED_WAITING）死亡（TERMINATED）七、J.U.C - AQSCountDownLatchCyclicBarrierSemaphore八、J.U.C - 其它组件FutureTaskBlockingQueueForkJoin九、线程不安全示例十、Java 内存模型主内存与工作内存内存间交互操作内存模型三大特性先行发生原则十一、线程安全不可变互斥同步非阻塞同步无同步方案十二、锁优化自旋锁锁消除锁粗化轻量级锁偏向锁十三、多线程开发良好的实践 一、使用线程有三种使用线程的方法： 实现 Runnable 接口；实现 Callable 接口；继承 Thread 类。实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以理解为任务是通过线程驱动从而执行的。 实现 Runnable 接口需要实现接口中的 run() 方法。 public class MyRunnable implements Runnable { @Override public void run() { // … }}使用 Runnable 实例再创建一个 Thread 实例，然后调用 Thread 实例的 start() 方法来启动线程。 public static void main(String[] args) { MyRunnable instance = new MyRunnable(); Thread thread = new Thread(instance); thread.start();}实现 Callable 接口与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。 public class MyCallable implements Callable { public Integer call() { return 123; }}public static void main(String[] args) throws ExecutionException, InterruptedException { MyCallable mc = new MyCallable(); FutureTask ft = new FutureTask&lt;&gt;(mc); Thread thread = new Thread(ft); thread.start(); System.out.println(ft.get());}继承 Thread 类同样也是需要实现 run() 方法，因为 Thread 类也实现了 Runable 接口。 当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。 public class MyThread extends Thread { public void run() { // … }}public static void main(String[] args) { MyThread mt = new MyThread(); mt.start();}实现接口 VS 继承 Thread实现接口会更好一些，因为： Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；类可能只要求可执行就行，继承整个 Thread 类开销过大。二、基础线程机制ExecutorExecutor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。 主要有三种 Executor： CachedThreadPool：一个任务创建一个线程；FixedThreadPool：所有任务只能使用固定大小的线程；SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool。public static void main(String[] args) { ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 5; i++) { executorService.execute(new MyRunnable()); } executorService.shutdown();}Daemon守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。 当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。 main() 属于非守护线程。 在线程启动之前使用 setDaemon() 方法可以将一个线程设置为守护线程。 public static void main(String[] args) { Thread thread = new Thread(new MyRunnable()); thread.setDaemon(true);}sleep()Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。 sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。 public void run() { try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); }}yield()对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。 public void run() { Thread.yield();}三、中断一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。 InterruptedException通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。 对于以下代码，在 main() 中启动一个线程之后再中断它，由于线程中调用了 Thread.sleep() 方法，因此会抛出一个 InterruptedException，从而提前结束线程，不执行之后的语句。 public class InterruptExample { private static class MyThread1 extends Thread { @Override public void run() { try { Thread.sleep(2000); System.out.println(&quot;Thread run&quot;); } catch (InterruptedException e) { e.printStackTrace(); } } } }public static void main(String[] args) throws InterruptedException { Thread thread1 = new MyThread1(); thread1.start(); thread1.interrupt(); System.out.println(“Main run”);}Main runjava.lang.InterruptedException: sleep interrupted at java.lang.Thread.sleep(Native Method) at InterruptExample.lambda$main$0(InterruptExample.java:5) at InterruptExample$$Lambda$1/713338599.run(Unknown Source) at java.lang.Thread.run(Thread.java:745)interrupted()如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。 但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。 public class InterruptExample { private static class MyThread2 extends Thread { @Override public void run() { while (!interrupted()) { // .. } System.out.println(&quot;Thread end&quot;); } } }public static void main(String[] args) throws InterruptedException { Thread thread2 = new MyThread2(); thread2.start(); thread2.interrupt();}Thread endExecutor 的中断操作调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。 以下使用 Lambda 创建线程，相当于创建了一个匿名内部线程。 public static void main(String[] args) { ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(() -&gt; { try { Thread.sleep(2000); System.out.println(“Thread run”); } catch (InterruptedException e) { e.printStackTrace(); } }); executorService.shutdownNow(); System.out.println(“Main run”);}Main runjava.lang.InterruptedException: sleep interrupted at java.lang.Thread.sleep(Native Method) at ExecutorInterruptExample.lambda$main$0(ExecutorInterruptExample.java:9) at ExecutorInterruptExample$$Lambda$1/1160460865.run(Unknown Source) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at java.lang.Thread.run(Thread.java:745)如果只想中断 Executor 中的一个线程，可以通过使用 submit() 方法来提交一个线程，它会返回一个 Future&lt;?&gt; 对象，通过调用该对象的 cancel(true) 方法就可以中断线程。 Future&lt;?&gt; future = executorService.submit(() -&gt; { // ..});future.cancel(true);四、互斥同步Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。 synchronized 同步一个代码块 public void func() { synchronized (this) { // … }}它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。 对于以下代码，使用 ExecutorService 执行了两个线程，由于调用的是同一个对象的同步代码块，因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须等待。 public class SynchronizedExample { public void func1() { synchronized (this) { for (int i = 0; i &lt; 10; i++) { System.out.print(i + &quot; &quot;); } } } }public static void main(String[] args) { SynchronizedExample e1 = new SynchronizedExample(); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(() -&gt; e1.func1()); executorService.execute(() -&gt; e1.func1());}0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9对于以下代码，两个线程调用了不同对象的同步代码块，因此这两个线程就不需要同步。从输出结果可以看出，两个线程交叉执行。 public static void main(String[] args) { SynchronizedExample e1 = new SynchronizedExample(); SynchronizedExample e2 = new SynchronizedExample(); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(() -&gt; e1.func1()); executorService.execute(() -&gt; e2.func1());}0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 同步一个方法 public synchronized void func () { // …}它和同步代码块一样，作用于同一个对象。 同步一个类 public void func() { synchronized (SynchronizedExample.class) { // … }}作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。 public class SynchronizedExample { public void func2() { synchronized (SynchronizedExample.class) { for (int i = 0; i &lt; 10; i++) { System.out.print(i + &quot; &quot;); } } } }public static void main(String[] args) { SynchronizedExample e1 = new SynchronizedExample(); SynchronizedExample e2 = new SynchronizedExample(); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(() -&gt; e1.func2()); executorService.execute(() -&gt; e2.func2());}0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 同步一个静态方法 public synchronized static void fun() { // …}作用于整个类。 ReentrantLockReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。 public class LockExample { private Lock lock = new ReentrantLock(); public void func() { lock.lock(); try { for (int i = 0; i &lt; 10; i++) { System.out.print(i + &quot; &quot;); } } finally { lock.unlock(); // 确保释放锁，从而避免发生死锁。 } } }public static void main(String[] args) { LockExample lockExample = new LockExample(); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(() -&gt; lockExample.func()); executorService.execute(() -&gt; lockExample.func());}0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9比较 锁的实现 synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。 性能 新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。 等待可中断 当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。 ReentrantLock 可中断，而 synchronized 不行。 公平锁 公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。 synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。 锁绑定多个条件 一个 ReentrantLock 可以同时绑定多个 Condition 对象。 使用选择除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。 五、线程之间的协作当多个线程可以一起工作去解决某个问题时，如果某些部分必须在其它部分之前完成，那么就需要对线程进行协调。 join()在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。 对于以下代码，虽然 b 线程先启动，但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出。 public class JoinExample { private class A extends Thread { @Override public void run() { System.out.println(&quot;A&quot;); } } private class B extends Thread { private A a; B(A a) { this.a = a; } @Override public void run() { try { a.join(); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&quot;B&quot;); } } public void test() { A a = new A(); B b = new B(a); b.start(); a.start(); } }public static void main(String[] args) { JoinExample example = new JoinExample(); example.test();}ABwait() notify() notifyAll()调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。 它们都属于 Object 的一部分，而不属于 Thread。 只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateException。 使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。 public class WaitNotifyExample { public synchronized void before() { System.out.println(&quot;before&quot;); notifyAll(); } public synchronized void after() { try { wait(); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(&quot;after&quot;); } }public static void main(String[] args) { ExecutorService executorService = Executors.newCachedThreadPool(); WaitNotifyExample example = new WaitNotifyExample(); executorService.execute(() -&gt; example.after()); executorService.execute(() -&gt; example.before());}beforeafterwait() 和 sleep() 的区别 wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法；wait() 会释放锁，sleep() 不会。await() signal() signalAll()java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。 相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。 使用 Lock 来获取一个 Condition 对象。 public class AwaitSignalExample { private Lock lock = new ReentrantLock(); private Condition condition = lock.newCondition(); public void before() { lock.lock(); try { System.out.println(&quot;before&quot;); condition.signalAll(); } finally { lock.unlock(); } } public void after() { lock.lock(); try { condition.await(); System.out.println(&quot;after&quot;); } catch (InterruptedException e) { e.printStackTrace(); } finally { lock.unlock(); } } }public static void main(String[] args) { ExecutorService executorService = Executors.newCachedThreadPool(); AwaitSignalExample example = new AwaitSignalExample(); executorService.execute(() -&gt; example.after()); executorService.execute(() -&gt; example.before());}beforeafter六、线程状态一个线程只能处于一种状态，并且这里的线程状态特指 Java 虚拟机的线程状态，不能反映线程在特定操作系统下的状态。 新建（NEW）创建后尚未启动。 可运行（RUNABLE）正在 Java 虚拟机中运行。但是在操作系统层面，它可能处于运行状态，也可能等待资源调度（例如处理器资源），资源调度完成就进入运行状态。所以该状态的可运行是指可以被运行，具体有没有运行要看底层操作系统的资源调度。 阻塞（BLOCKED）请求获取 monitor lock 从而进入 synchronized 函数或者代码块，但是其它线程已经占用了该 monitor lock，所以出于阻塞状态。要结束该状态进入从而 RUNABLE 需要其他线程释放 monitor lock。 无限期等待（WAITING）等待其它线程显式地唤醒。 阻塞和等待的区别在于，阻塞是被动的，它是在等待获取 monitor lock。而等待是主动的，通过调用 Object.wait() 等方法进入。 进入方法 退出方法没有设置 Timeout 参数的 Object.wait() 方法 Object.notify() / Object.notifyAll()没有设置 Timeout 参数的 Thread.join() 方法 被调用的线程执行完毕LockSupport.park() 方法 LockSupport.unpark(Thread)限期等待（TIMED_WAITING）无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。 进入方法 退出方法Thread.sleep() 方法 时间结束设置了 Timeout 参数的 Object.wait() 方法 时间结束 / Object.notify() / Object.notifyAll()设置了 Timeout 参数的 Thread.join() 方法 时间结束 / 被调用的线程执行完毕LockSupport.parkNanos() 方法 LockSupport.unpark(Thread)LockSupport.parkUntil() 方法 LockSupport.unpark(Thread)调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。 死亡（TERMINATED）可以是线程结束任务之后自己结束，或者产生了异常而结束。 Java SE 9 Enum Thread.State 七、J.U.C - AQSjava.util.concurrent（J.U.C）大大提高了并发性能，AQS 被认为是 J.U.C 的核心。 CountDownLatch用来控制一个或者多个线程等待多个线程。 维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。 public class CountdownLatchExample { public static void main(String[] args) throws InterruptedException { final int totalThread = 10; CountDownLatch countDownLatch = new CountDownLatch(totalThread); ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; totalThread; i++) { executorService.execute(() -&gt; { System.out.print(&quot;run..&quot;); countDownLatch.countDown(); }); } countDownLatch.await(); System.out.println(&quot;end&quot;); executorService.shutdown(); } }run..run..run..run..run..run..run..run..run..run..endCyclicBarrier用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。 和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行。 CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。 CyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次。 public CyclicBarrier(int parties, Runnable barrierAction) { if (parties &lt;= 0) throw new IllegalArgumentException(); this.parties = parties; this.count = parties; this.barrierCommand = barrierAction;} public CyclicBarrier(int parties) { this(parties, null);} public class CyclicBarrierExample { public static void main(String[] args) { final int totalThread = 10; CyclicBarrier cyclicBarrier = new CyclicBarrier(totalThread); ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; totalThread; i++) { executorService.execute(() -&gt; { System.out.print(&quot;before..&quot;); try { cyclicBarrier.await(); } catch (InterruptedException | BrokenBarrierException e) { e.printStackTrace(); } System.out.print(&quot;after..&quot;); }); } executorService.shutdown(); } }before..before..before..before..before..before..before..before..before..before..after..after..after..after..after..after..after..after..after..after..SemaphoreSemaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。 以下代码模拟了对某个服务的并发请求，每次只能有 3 个客户端同时访问，请求总数为 10。 public class SemaphoreExample { public static void main(String[] args) { final int clientCount = 3; final int totalRequestCount = 10; Semaphore semaphore = new Semaphore(clientCount); ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; totalRequestCount; i++) { executorService.execute(()-&gt;{ try { semaphore.acquire(); System.out.print(semaphore.availablePermits() + &quot; &quot;); } catch (InterruptedException e) { e.printStackTrace(); } finally { semaphore.release(); } }); } executorService.shutdown(); } }2 1 2 2 2 2 2 1 2 2八、J.U.C - 其它组件FutureTask在介绍 Callable 时我们知道它可以有返回值，返回值通过 Future 进行封装。FutureTask 实现了 RunnableFuture 接口，该接口继承自 Runnable 和 Future 接口，这使得 FutureTask 既可以当做一个任务执行，也可以有返回值。 public class FutureTask implements RunnableFuturepublic interface RunnableFuture extends Runnable, FutureFutureTask 可用于异步获取执行结果或取消执行任务的场景。当一个计算任务需要执行很长时间，那么就可以用 FutureTask 来封装这个任务，主线程在完成自己的任务之后再去获取结果。 public class FutureTaskExample { public static void main(String[] args) throws ExecutionException, InterruptedException { FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(new Callable&lt;Integer&gt;() { @Override public Integer call() throws Exception { int result = 0; for (int i = 0; i &lt; 100; i++) { Thread.sleep(10); result += i; } return result; } }); Thread computeThread = new Thread(futureTask); computeThread.start(); Thread otherThread = new Thread(() -&gt; { System.out.println(&quot;other task is running...&quot;); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } }); otherThread.start(); System.out.println(futureTask.get()); } }other task is running…4950BlockingQueuejava.util.concurrent.BlockingQueue 接口有以下阻塞队列的实现： FIFO 队列 ：LinkedBlockingQueue、ArrayBlockingQueue（固定长度）优先级队列 ：PriorityBlockingQueue提供了阻塞的 take() 和 put() 方法：如果队列为空 take() 将阻塞，直到队列中有内容；如果队列为满 put() 将阻塞，直到队列有空闲位置。 使用 BlockingQueue 实现生产者消费者问题 public class ProducerConsumer { private static BlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue&lt;&gt;(5); private static class Producer extends Thread { @Override public void run() { try { queue.put(&quot;product&quot;); } catch (InterruptedException e) { e.printStackTrace(); } System.out.print(&quot;produce..&quot;); } } private static class Consumer extends Thread { @Override public void run() { try { String product = queue.take(); } catch (InterruptedException e) { e.printStackTrace(); } System.out.print(&quot;consume..&quot;); } } }public static void main(String[] args) { for (int i = 0; i &lt; 2; i++) { Producer producer = new Producer(); producer.start(); } for (int i = 0; i &lt; 5; i++) { Consumer consumer = new Consumer(); consumer.start(); } for (int i = 0; i &lt; 3; i++) { Producer producer = new Producer(); producer.start(); }}produce..produce..consume..consume..produce..consume..produce..consume..produce..consume..ForkJoin主要用于并行计算中，和 MapReduce 原理类似，都是把大的计算任务拆分成多个小任务并行计算。 public class ForkJoinExample extends RecursiveTask { private final int threshold = 5; private int first; private int last; public ForkJoinExample(int first, int last) { this.first = first; this.last = last; } @Override protected Integer compute() { int result = 0; if (last - first &lt;= threshold) { // 任务足够小则直接计算 for (int i = first; i &lt;= last; i++) { result += i; } } else { // 拆分成小任务 int middle = first + (last - first) / 2; ForkJoinExample leftTask = new ForkJoinExample(first, middle); ForkJoinExample rightTask = new ForkJoinExample(middle + 1, last); leftTask.fork(); rightTask.fork(); result = leftTask.join() + rightTask.join(); } return result; } }public static void main(String[] args) throws ExecutionException, InterruptedException { ForkJoinExample example = new ForkJoinExample(1, 10000); ForkJoinPool forkJoinPool = new ForkJoinPool(); Future result = forkJoinPool.submit(example); System.out.println(result.get());}ForkJoin 使用 ForkJoinPool 来启动，它是一个特殊的线程池，线程数量取决于 CPU 核数。 public class ForkJoinPool extends AbstractExecutorServiceForkJoinPool 实现了工作窃取算法来提高 CPU 的利用率。每个线程都维护了一个双端队列，用来存储需要执行的任务。工作窃取算法允许空闲的线程从其它线程的双端队列中窃取一个任务来执行。窃取的任务必须是最晚的任务，避免和队列所属线程发生竞争。例如下图中，Thread2 从 Thread1 的队列中拿出最晚的 Task1 任务，Thread1 会拿出 Task2 来执行，这样就避免发生竞争。但是如果队列中只有一个任务时还是会发生竞争。 九、线程不安全示例如果多个线程对同一个共享数据进行访问而不采取同步操作的话，那么操作的结果是不一致的。 以下代码演示了 1000 个线程同时对 cnt 执行自增操作，操作结束之后它的值有可能小于 1000。 public class ThreadUnsafeExample { private int cnt = 0; public void add() { cnt++; } public int get() { return cnt; } }public static void main(String[] args) throws InterruptedException { final int threadSize = 1000; ThreadUnsafeExample example = new ThreadUnsafeExample(); final CountDownLatch countDownLatch = new CountDownLatch(threadSize); ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; threadSize; i++) { executorService.execute(() -&gt; { example.add(); countDownLatch.countDown(); }); } countDownLatch.await(); executorService.shutdown(); System.out.println(example.get());}997十、Java 内存模型Java 内存模型试图屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。 主内存与工作内存处理器上的寄存器的读写的速度比内存快几个数量级，为了解决这种速度矛盾，在它们之间加入了高速缓存。 加入高速缓存带来了一个新的问题：缓存一致性。如果多个缓存共享同一块主内存区域，那么多个缓存的数据可能会不一致，需要一些协议来解决这个问题。 所有的变量都存储在主内存中，每个线程还有自己的工作内存，工作内存存储在高速缓存或者寄存器中，保存了该线程使用的变量的主内存副本拷贝。 线程只能直接操作工作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成。 内存间交互操作Java 内存模型定义了 8 个操作来完成主内存和工作内存的交互操作。 read：把一个变量的值从主内存传输到工作内存中load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中use：把工作内存中一个变量的值传递给执行引擎assign：把一个从执行引擎接收到的值赋给工作内存的变量store：把工作内存的一个变量的值传送到主内存中write：在 store 之后执行，把 store 得到的值放入主内存的变量中lock：作用于主内存的变量unlock内存模型三大特性 原子性Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有原子性，例如对一个 int 类型的变量执行 assign 赋值操作，这个操作就是原子性的。但是 Java 内存模型允许虚拟机将没有被 volatile 修饰的 64 位数据（long，double）的读写操作划分为两次 32 位的操作来进行，即 load、store、read 和 write 操作可以不具备原子性。 有一个错误认识就是，int 等原子性的类型在多线程环境中不会出现线程安全问题。前面的线程不安全示例代码中，cnt 属于 int 类型变量，1000 个线程对它进行自增操作之后，得到的值为 997 而不是 1000。 为了方便讨论，将内存间的交互操作简化为 3 个：load、assign、store。 下图演示了两个线程同时对 cnt 进行操作，load、assign、store 这一系列操作整体上看不具备原子性，那么在 T1 修改 cnt 并且还没有将修改后的值写入主内存，T2 依然可以读入旧值。可以看出，这两个线程虽然执行了两次自增运算，但是主内存中 cnt 的值最后为 1 而不是 2。因此对 int 类型读写操作满足原子性只是说明 load、assign、store 这些单个操作具备原子性。 AtomicInteger 能保证多个线程修改的原子性。 使用 AtomicInteger 重写之前线程不安全的代码之后得到以下线程安全实现： public class AtomicExample { private AtomicInteger cnt = new AtomicInteger(); public void add() { cnt.incrementAndGet(); } public int get() { return cnt.get(); } }public static void main(String[] args) throws InterruptedException { final int threadSize = 1000; AtomicExample example = new AtomicExample(); // 只修改这条语句 final CountDownLatch countDownLatch = new CountDownLatch(threadSize); ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; threadSize; i++) { executorService.execute(() -&gt; { example.add(); countDownLatch.countDown(); }); } countDownLatch.await(); executorService.shutdown(); System.out.println(example.get());}1000除了使用原子类之外，也可以使用 synchronized 互斥锁来保证操作的原子性。它对应的内存间交互操作为：lock 和 unlock，在虚拟机实现上对应的字节码指令为 monitorenter 和 monitorexit。 public class AtomicSynchronizedExample { private int cnt = 0; public synchronized void add() { cnt++; } public synchronized int get() { return cnt; } }public static void main(String[] args) throws InterruptedException { final int threadSize = 1000; AtomicSynchronizedExample example = new AtomicSynchronizedExample(); final CountDownLatch countDownLatch = new CountDownLatch(threadSize); ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; threadSize; i++) { executorService.execute(() -&gt; { example.add(); countDownLatch.countDown(); }); } countDownLatch.await(); executorService.shutdown(); System.out.println(example.get());}1000 可见性可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。 主要有三种实现可见性的方式： volatilesynchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。对前面的线程不安全示例中的 cnt 变量使用 volatile 修饰，不能解决线程不安全问题，因为 volatile 并不能保证操作的原子性。 有序性有序性是指：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。 volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。 也可以通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。 先行发生原则上面提到了可以用 volatile 和 synchronized 来保证有序性。除此之外，JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。 单一线程原则Single Thread rule 在一个线程内，在程序前面的操作先行发生于后面的操作。 管程锁定规则Monitor Lock Rule 一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。 volatile 变量规则Volatile Variable Rule 对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。 线程启动规则Thread Start Rule Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。 线程加入规则Thread Join Rule Thread 对象的结束先行发生于 join() 方法返回。 线程中断规则Thread Interruption Rule 对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。 对象终结规则Finalizer Rule 一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。 传递性Transitivity 如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。 十一、线程安全多个线程不管以何种方式访问某个类，并且在主调代码中不需要进行同步，都能表现正确的行为。 线程安全有以下几种实现方式： 不可变不可变（Immutable）的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。多线程环境下，应当尽量使对象成为不可变，来满足线程安全。 不可变的类型： final 关键字修饰的基本数据类型String枚举类型Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。对于集合类型，可以使用 Collections.unmodifiableXXX() 方法来获取一个不可变的集合。 public class ImmutableExample { public static void main(String[] args) { Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); Map&lt;String, Integer&gt; unmodifiableMap = Collections.unmodifiableMap(map); unmodifiableMap.put(“a”, 1); }}Exception in thread “main” java.lang.UnsupportedOperationException at java.util.Collections$UnmodifiableMap.put(Collections.java:1457) at ImmutableExample.main(ImmutableExample.java:9)Collections.unmodifiableXXX() 先对原始的集合进行拷贝，需要对集合进行修改的方法都直接抛出异常。 public V put(K key, V value) { throw new UnsupportedOperationException();}互斥同步synchronized 和 ReentrantLock。 非阻塞同步互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。 互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。 随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。 CAS乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是：比较并交换（Compare-and-Swap，CAS）。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。 AtomicIntegerJ.U.C 包里面的整数原子类 AtomicInteger 的方法调用了 Unsafe 类的 CAS 操作。 以下代码使用了 AtomicInteger 执行了自增的操作。 private AtomicInteger cnt = new AtomicInteger(); public void add() { cnt.incrementAndGet();}以下代码是 incrementAndGet() 的源码，它调用了 Unsafe 的 getAndAddInt() 。 public final int incrementAndGet() { return unsafe.getAndAddInt(this, valueOffset, 1) + 1;}以下代码是 getAndAddInt() 源码，var1 指示对象内存地址，var2 指示该字段相对对象内存地址的偏移，var4 指示操作需要加的数值，这里为 1。通过 getIntVolatile(var1, var2) 得到旧的预期值，通过调用 compareAndSwapInt() 来进行 CAS 比较，如果该字段内存地址中的值等于 var5，那么就更新内存地址为 var1+var2 的变量为 var5+var4。 可以看到 getAndAddInt() 在一个循环中进行，发生冲突的做法是不断的进行重试。 public final int getAndAddInt(Object var1, long var2, int var4) { int var5; do { var5 = this.getIntVolatile(var1, var2); } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5; } ABA如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。 J.U.C 包提供了一个带有标记的原子引用类 AtomicStampedReference 来解决这个问题，它可以通过控制变量值的版本来保证 CAS 的正确性。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。 无同步方案要保证线程安全，并不是一定就要进行同步。如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性。 栈封闭多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。 public class StackClosedExample { public void add100() { int cnt = 0; for (int i = 0; i &lt; 100; i++) { cnt++; } System.out.println(cnt); }}public static void main(String[] args) { StackClosedExample example = new StackClosedExample(); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(() -&gt; example.add100()); executorService.execute(() -&gt; example.add100()); executorService.shutdown();}100100 线程本地存储（Thread Local Storage）如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。 符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典 Web 交互模型中的“一个请求对应一个服务器线程”（Thread-per-Request）的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使用线程本地存储来解决线程安全问题。 可以使用 java.lang.ThreadLocal 类来实现线程本地存储功能。 对于以下代码，thread1 中设置 threadLocal 为 1，而 thread2 设置 threadLocal 为 2。过了一段时间之后，thread1 读取 threadLocal 依然是 1，不受 thread2 的影响。 public class ThreadLocalExample { public static void main(String[] args) { ThreadLocal threadLocal = new ThreadLocal(); Thread thread1 = new Thread(() -&gt; { threadLocal.set(1); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(threadLocal.get()); threadLocal.remove(); }); Thread thread2 = new Thread(() -&gt; { threadLocal.set(2); threadLocal.remove(); }); thread1.start(); thread2.start(); }}1为了理解 ThreadLocal，先看以下代码： public class ThreadLocalExample1 { public static void main(String[] args) { ThreadLocal threadLocal1 = new ThreadLocal(); ThreadLocal threadLocal2 = new ThreadLocal(); Thread thread1 = new Thread(() -&gt; { threadLocal1.set(1); threadLocal2.set(1); }); Thread thread2 = new Thread(() -&gt; { threadLocal1.set(2); threadLocal2.set(2); }); thread1.start(); thread2.start(); }}它所对应的底层结构图为： 每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象。 /* ThreadLocal values pertaining to this thread. This map is maintained by the ThreadLocal class. */ThreadLocal.ThreadLocalMap threadLocals = null;当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal-&gt;value 键值对插入到该 Map 中。 public void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);}get() 方法类似。 public T get() { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings(“unchecked”) T result = (T)e.value; return result; } } return setInitialValue();}ThreadLocal 从理论上讲并不是用来解决多线程并发问题的，因为根本不存在多线程竞争。 在一些场景 (尤其是使用线程池) 下，由于 ThreadLocal.ThreadLocalMap 的底层数据结构导致 ThreadLocal 有内存泄漏的情况，应该尽可能在每次使用 ThreadLocal 后手动调用 remove()，以避免出现 ThreadLocal 经典的内存泄漏甚至是造成自身业务混乱的风险。 可重入代码（Reentrant Code）这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。 可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。 十二、锁优化这里的锁优化主要是指 JVM 对 synchronized 的优化。 自旋锁互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。 自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。 在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。 锁消除锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。 锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。 对于一些看起来没有加锁的代码，其实隐式的加了很多锁。例如下面的字符串拼接代码就隐式加了锁： public static String concatString(String s1, String s2, String s3) { return s1 + s2 + s3;}String 是一个不可变的类，编译器会对 String 的拼接自动优化。在 JDK 1.5 之前，会转化为 StringBuffer 对象的连续 append() 操作： public static String concatString(String s1, String s2, String s3) { StringBuffer sb = new StringBuffer(); sb.append(s1); sb.append(s2); sb.append(s3); return sb.toString();}每个 append() 方法中都有一个同步块。虚拟机观察变量 sb，很快就会发现它的动态作用域被限制在 concatString() 方法内部。也就是说，sb 的所有引用永远不会逃逸到 concatString() 方法之外，其他线程无法访问到它，因此可以进行消除。 锁粗化如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。 上一节的示例代码中连续的 append() 方法就属于这类情况。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。对于上一节的示例代码就是扩展到第一个 append() 操作之前直至最后一个 append() 操作之后，这样只需要加锁一次就可以了。 轻量级锁JDK 1.6 引入了偏向锁和轻量级锁，从而让锁拥有了四个状态：无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）。 以下是 HotSpot 虚拟机对象头的内存布局，这些数据被称为 Mark Word。其中 tag bits 对应了五个状态，这些状态在右侧的 state 表格中给出。除了 marked for gc 状态，其它四个状态已经在前面介绍过了。 下图左侧是一个线程的虚拟机栈，其中有一部分称为 Lock Record 的区域，这是在轻量级锁运行过程创建的，用于存放锁对象的 Mark Word。而右侧就是一个锁对象，包含了 Mark Word 和其它信息。 轻量级锁是相对于传统的重量级锁而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。 当尝试获取一个锁对象时，如果锁对象标记为 0 01，说明锁对象的锁未锁定（unlocked）状态。此时虚拟机在当前线程的虚拟机栈中创建 Lock Record，然后使用 CAS 操作将对象的 Mark Word 更新为 Lock Record 指针。如果 CAS 操作成功了，那么线程就获取了该对象上的锁，并且对象的 Mark Word 的锁标记变为 00，表示该对象处于轻量级锁状态。 如果 CAS 操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的虚拟机栈，如果是的话说明当前线程已经拥有了这个锁对象，那就可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁。 偏向锁偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。 当锁对象第一次被线程获得的时候，进入偏向状态，标记为 1 01。同时使用 CAS 操作将线程 ID 记录到 Mark Word 中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块就不需要再进行任何同步操作。 当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定状态或者轻量级锁状态。 十三、多线程开发良好的实践给线程起个有意义的名字，这样可以方便找 Bug。 缩小同步范围，从而减少锁争用。例如对于 synchronized，应该尽量使用同步块而不是同步方法。 多用同步工具少用 wait() 和 notify()。首先，CountDownLatch, CyclicBarrier, Semaphore 和 Exchanger 这些同步类简化了编码操作，而用 wait() 和 notify() 很难实现复杂控制流；其次，这些同步类是由最好的企业编写和维护，在后续的 JDK 中还会不断优化和完善。 使用 BlockingQueue 实现生产者消费者问题。 多用并发集合少用同步集合，例如应该使用 ConcurrentHashMap 而不是 Hashtable。 使用本地变量和不可变类来保证线程安全。 使用线程池而不是直接创建线程，这是因为创建线程代价很高，线程池可以有效地利用有限的线程来启动任务。]]></content>
  </entry>
  <entry>
    <title><![CDATA[计算机网络--传输层]]></title>
    <url>%2F2019%2F10%2F16%2F%E7%BD%91%E7%BB%9C%2F%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E4%BC%A0%E8%BE%93%E5%B1%82%2F</url>
    <content type="text"><![CDATA[&gt; 网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。UDP 和 TCP 的特点用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。UDP 首部格式 首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。TCP 首部格式 序号 ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。确认号 ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。数据偏移 ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。确认 ACK ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。同步 SYN ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。终止 FIN ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。窗口 ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。TCP 的三次握手 假设 A 为客户端，B 为服务器端。首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。B 收到 A 的确认后，连接建立。三次握手的原因第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。TCP 的四次挥手 以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。A 发送连接释放报文，FIN=1。B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。当 B 不再需要连接时，发送连接释放报文，FIN=1。A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。B 收到 A 的确认后释放连接。四次挥手的原因客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。TIME_WAIT客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。TCP 可靠传输TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下： 其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下： 其中 RTTd 为偏差的加权平均值。TCP 滑动窗口窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。 TCP 流量控制流量控制是为了控制发送方发送速率，保证接收方来得及接收。接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。TCP 拥塞控制如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。 TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。为了便于讨论，做如下假设：接收方有足够大的接收缓存，因此不会发生流量控制；虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。 1. 慢开始与拥塞避免发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。2. 快重传与快恢复在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。]]></content>
      <categories>
        <category>网络</category>
        <category>【计算机网络】</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络--应用层]]></title>
    <url>%2F2019%2F10%2F16%2F%E7%BD%91%E7%BB%9C%2F%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E5%BA%94%E7%94%A8%E5%B1%82%2F</url>
    <content type="text"><![CDATA[域名系统DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。 DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。在两种情况下会使用 TCP 进行传输：如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。文件传送协议FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件：控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。数据连接：用来传送一个文件数据。根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式：主动模式：服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。 被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。 主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。动态主机配置协议DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。DHCP 工作过程如下：客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。 远程登录协议TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。电子邮件协议一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。 1. SMTPSMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。 2. POP3POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。但最新版本的 POP3 可以不删除邮件。3. IMAPIMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。常用端口应用应用层协议端口号传输层协议备注域名解析DNS53UDP/TCP长度超过 512 字节时使用 TCP动态主机配置协议DHCP67/68UDP简单网络管理协议SNMP161/162UDP文件传送协议FTP20/21TCP控制连接 21，数据连接 20远程终端协议TELNET23TCP超文本传送协议HTTP80TCP简单邮件传送协议SMTP25TCP邮件读取协议POP3110TCP网际报文存取协议IMAP143TCPWeb 页面请求过程1. DHCP 配置主机信息假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。该数据报则被放置在 MAC 帧中，该帧具有目的地址 FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备。连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。2. ARP 解析 MAC 地址主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:FF:FF:FF:FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。3. DNS 解析域名知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。4. HTTP 请求页面有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。]]></content>
      <categories>
        <category>网络</category>
        <category>【计算机网络】</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络--数据链路层]]></title>
    <url>%2F2019%2F10%2F16%2F%E7%BD%91%E7%BB%9C%2F%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%2F</url>
    <content type="text"><![CDATA[解决的三大基本问题1. 封装成帧将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。在一段数据的前后分别添加首部和尾部（帧定界），这样就构成了一个帧。 最大传送单元MTU —- 数据部分长度上限 2. 透明传输透明表示一个实际存在的事物看起来好像不存在一样。表示无论什么样的比特组合的数据，都能按照原样没有差错地通过这个数据链路图进行传送。 帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。可以通过字节填充或者字符填充的方法进行处理，在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。 3. 差错检测比特差错：11可能变成0，0可能变成1目前数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错。凡是接收端数据链路层接受的帧均无差错。 异或运算。除数有4为，所以需要加3个0。 信道分类1. 广播信道一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 CSMA/CD 协议。 2. 点对点信道一对一通信。 因为不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。 CSMA/CD 协议CSMA/CD 表示载波监听多点接入 / 碰撞检测。 多点接入 ：说明这是总线型网络，许多主机以多点的方式连接到总线上。载波监听 ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。碰撞检测 ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为 争用期 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。 当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 截断二进制指数退避算法 来确定。从离散的整数集合 {0, 1, .., (2k-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。 PPP 协议互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。 PPP 的帧格式： F 字段为帧的定界符A 和 C 字段暂时没有意义FCS 字段是使用 CRC 的检验序列信息部分的长度不超过 1500 MAC 地址MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。 一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。 局域网局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。 主要有以太网、令牌环网、FDDI 和 ATM 等局域网技术，目前以太网占领着有线局域网市场。 可以按照网络拓扑结构对局域网进行分类： 以太网以太网是一种星型拓扑结构局域网。 早期使用集线器进行连接，集线器是一种物理层设备， 作用于比特而不是帧，当一个比特到达接口时，集线器重新生成这个比特，并将其能量强度放大，从而扩大网络的传输距离，之后再将这个比特发送到其它所有接口。如果集线器同时收到两个不同接口的帧，那么就发生了碰撞。 目前以太网使用交换机替代了集线器，交换机是一种链路层设备，它不会发生碰撞，能根据 MAC 地址进行存储转发。 以太网帧格式： 类型 ：标记上层使用的协议；数据 ：长度在 46-1500 之间，如果太小则需要填充；FCS ：帧检验序列，使用的是 CRC 检验方法； 交换机交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。 正是由于这种自学习能力，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容。 下图中，交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入交换表中。为了发送数据帧到 B，先查交换表，此时没有主机 B 的表项，那么主机 A 就发送广播帧，主机 C 和主机 D 会丢弃该帧，主机 B 回应该帧向主机 A 发送数据包时，交换机查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 2 的映射。 虚拟局域网虚拟局域网可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网中的成员才会收到链路层广播信息。 例如下图中 (A1, A2, A3, A4) 属于一个虚拟局域网，A1 发送的广播会被 A2、A3、A4 收到，而其它站点收不到。 使用 VLAN 干线连接来建立虚拟局域网，每台交换机上的一个特殊接口被设置为干线接口，以互连 VLAN 交换机。IEEE 定义了一种扩展的以太网帧格式 802.1Q，它在标准以太网帧上加进了 4 字节首部 VLAN 标签，用于表示该帧属于哪一个虚拟局域网。]]></content>
      <categories>
        <category>网络</category>
        <category>【计算机网络】</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络--概述]]></title>
    <url>%2F2019%2F10%2F16%2F%E7%BD%91%E7%BB%9C%2F%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[计算机网络是什么？有什么作用？计算机网络是由若干结点和连接这些这些结点的链路组成，是信息交流的基础。具有连通性和共享（资源共享） 网络的网络 网络把主机连接起来，而互连网（internet）是把多种不同的网络通过路由器连接起来，因此互连网是网络的网络。而互联网（Internet）是全球范围的互连网。 互联网服务提供商ISP互联网服务提供商 ISP 可以从互联网管理机构获得许多 IP 地址，同时拥有通信线路以及路由器等联网设备，个人或机构向 ISP 缴纳一定的费用就可以接入互联网。 目前的互联网是一种多层次 ISP 结构，ISP 根据覆盖面积的大小分为第一层 ISP、区域 ISP 和接入 ISP。互联网交换点 IXP 允许两个 ISP 直接相连而不用经过第三个 ISP。 主机之间的通信方式客户-服务器（C/S）：客户是服务的请求方，服务器是服务的提供方。 对等连接（P2P）：不区分客户和服务器。 电路交换与分组交换1. 电路交换电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。需要经过“建立连接（占用通信资源）”-&gt;“通话（一直占用通信资源）”-&gt;“释放连接（归还通信资源）”三个步骤。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。 2. 分组交换每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路。 在一个邮局通信系统中，邮局收到一份邮件之后，先存储下来，然后把相同目的地的邮件一起转发到下一个目的地，这个过程就是存储转发过程，分组交换也使用了存储转发过程。 3.三种交换方式在数据传送阶段的主要特点如下： 计算机网络的类别 按照网络作用范围划分为：广域网、城域网、局域网、个人区域网 按照网络的使用者进行划分为：公用网、专用网。 计算机网路的性能指标 计算机网络体系结构1. 五层协议应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。 传输层 ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。 网络层 ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。 数据链路层 ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。 物理层 ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。 2. OSI七层结构其中表示层和会话层用途如下： 表示层 ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。 会话层 ：建立及管理会话。 五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。 3. TCP/IP结构它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。 TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。 三种分层结构图： 4. 数据在各层之间的传递过程在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。 路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要传输层和应用层。]]></content>
      <categories>
        <category>网络</category>
        <category>【计算机网络】</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络--网络层]]></title>
    <url>%2F2019%2F10%2F16%2F%E7%BD%91%E7%BB%9C%2F%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%BD%91%E7%BB%9C%E5%B1%82%2F</url>
    <content type="text"><![CDATA[概述IP 数据报格式IP 地址编址方式1. 分类2. 子网划分3. 无分类地址解析协议 ARP网际控制报文协议 ICMP1. Ping2. Traceroute虚拟专用网 VPN网络地址转换 NAT路由器的结构路由器分组转发流程路由选择协议1. 内部网关协议 RIP2. 内部网关协议 OSPF3. 外部网关协议 BGP概述因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。 与 IP 协议配套使用的还有三个协议：地址解析协议 ARP（Address Resolution Protocol）网际控制报文协议 ICMP（Internet Control Message Protocol）网际组管理协议 IGMP（Internet Group Management Protocol）IP 数据报格式 版本 : 有 4（IPv4）和 6（IPv6）两个值；首部长度 : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。区分服务 : 用来获得更好的服务，一般情况下不使用。总长度 : 包括首部长度和数据部分长度。生存时间 ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。协议 ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。首部检验和 ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。标识 : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。片偏移 : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。 IP 地址编址方式IP 地址的编址方式经历了三个历史阶段：分类子网划分无分类1. 分类由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;} 2. 子网划分通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;}要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。注意，外部网络看不到子网的存在。3. 无分类无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;}CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 构成超网 。在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。地址解析协议 ARP网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。 ARP 实现由 IP 地址得到 MAC 地址。 每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。 网际控制报文协议 ICMPICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。 ICMP 报文分为差错报告报文和询问报文。 1. PingPing 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。2. TracerouteTraceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。虚拟专用网 VPN由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。有三个专用地址块：10.0.0.0 ~ 10.255.255.255172.16.0.0 ~ 172.31.255.255192.168.0.0 ~ 192.168.255.255VPN 使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚拟指好像是，而实际上并不是，它有经过公用的互联网。下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。 网络地址转换 NAT专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。 路由器的结构路由器从功能上可以划分为：路由选择和分组转发。分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。 路由器分组转发流程从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付；若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器；若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器；若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；报告转发分组出错。 路由选择协议路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。可以把路由选择协议划分为两大类：自治系统内部的路由选择：RIP 和 OSPF自治系统间的路由选择：BGP1. 内部网关协议 RIPRIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。距离向量算法：对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；对修改后的 RIP 报文中的每一个项目，进行以下步骤：若原来的路由表中没有目的网络 N，则把该项目添加到路由表中；否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。2. 内部网关协议 OSPF开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。OSPF 具有以下特点：向本自治系统中的所有路由器发送信息，这种方法是洪泛法。发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。只有当链路状态发生变化时，路由器才会发送信息。所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。3. 外部网关协议 BGPBGP（Border Gateway Protocol，边界网关协议）AS 之间的路由选择很困难，主要是由于：互联网规模很大；各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。BGP 只能寻找一条比较好的路由，而不是最佳路由。每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。]]></content>
      <categories>
        <category>网络</category>
        <category>【计算机网络】</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络--物理层]]></title>
    <url>%2F2019%2F10%2F16%2F%E7%BD%91%E7%BB%9C%2F%E3%80%90%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E3%80%91%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E7%89%A9%E7%90%86%E5%B1%82%2F</url>
    <content type="text"><![CDATA[物理层所要解决的问题？解决如何在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。 确定与接口相关的一些特性 机械特性：接口形状大小、引线数目 电气特性：接口电缆上的各条线出现的电压的范围。例如电压范围 -5 -&gt; +5 功能特性：指明某条线上出现的某一电平的电压的意义 过程特性：规程特性，规定建立连接时各个相关部件的工作步骤 数据通信1.通信系统模型数据通信系统可划分为：源系统、传输系统、目的系统。 12345678910111213数据通信模型 目的 传送消息 数据 运送消息的实体 信号 数据的电气的或电磁的表现 模拟信号 代表消息的参数的取值是连续的 数字信号 代表消息的参数的取值是离散的 码元 在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形就成为码元 2.信道相关知识点123456789101112131415161718192021信道 信道一般表示向一个方向传送信息的媒体 平常的通信线路 包含一条发送消息的信道 一条接受信号的信道 分类 单向通信（单工通信） 只能有一个方向的通信而灭有反方向的交互 双向交替通信（半双工通信） 通信的双方都可以发送信息，但不能双方同时发送（当然也不能同时接收） 双向同时通信（全双工通信） 通信的双方可以同时发送和接收信息 基带信号（基本频带信号） 来自信源的信号 计算机输出的代表各种文字或图像文件的数据信号都属于基带信号 发出的直接表达了要传输的信息的信号。 带通信号 把基带信号经过载波调制后，把信号的频率范围移到较高的频段以便在信道中传输 带通调制 模拟信号是连续的信号，数字信号是离散的信号。带通调制把数字信号转换为模拟信号。 调制方法 调幅、调频、调相 3.常见编码方式 单极性/双极性不归零码：正电平表示1，负电平代表0. 单极性/双极性归零码：正脉冲代表1，负脉冲代表0. 曼彻斯特编码：bit中间有信号。低到高 -&gt; 0，高到低 -&gt; 1 差分曼彻斯特编码 4.信道极限容量 奈氏准则：在任何信道中，码元传输的速率是有上限的，传输速率超过此上限，就会出现严重的码间串扰的问题，使接收端对码元的判决成为不可能 信噪比 香农公式：信道的带宽或信道中的信噪比越大，信号的极限传输速率就越高 传输媒体 导向/导引型传输媒体：电磁波沿着固体媒体传播 双绞线 屏蔽双绞线STP 、无屏蔽双绞线UTP 同轴电缆 有线电视 光缆 非引导型传输媒体：无线电微波。例如地面微波接力通信和卫星通信 信道复用技术复用是通信技术中的基本概念。 1.频分复用FDM所有用户在同样时间占用不同的带宽资源。 2.时分复用TDM（同步时分复用）所用用户在不同的时间占用同样的频带宽度 使用频分复用和时分复用进行通信，在通信的过程中主机会一直占用一部分信道资源。但是由于计算机数据的突发性质，通信过程没必要一直占用信道资源而不让出给其它用户使用，因此这两种方式对信道的利用率都不高。可能造成线路资源的浪费 3.统计时分复用STDM（异步时分复用）是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送。 4.波分复用（光的频分复用）光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。 5.码分复用码分复用有很强的抗干扰能力，不易被发现（常用于传送机密）。码分复用CDMA:码片：每一个比特事件再划分为m个短的间隔。 码片序列的正交关系 工作原理 一些技术了解]]></content>
      <categories>
        <category>网络</category>
        <category>【计算机网络】</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一个神奇的安全框架Shiro]]></title>
    <url>%2F2019%2F08%2F18%2FWeb%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%2F%E3%80%90Shiro%E5%AD%A6%E4%B9%A0%E3%80%91%2F%E4%B8%80%E4%B8%AA%E7%A5%9E%E5%A5%87%E7%9A%84%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6shiro%2F</url>
    <content type="text"><![CDATA[安全框架：Apache Shiro什么是Apache Shiro?Apache Shiro是一个功能强大且易于使用的Java安全框架，可执行身份验证，授权，加密和会话管理，并可用于保护任何应用程序。从命令行应用程序，移动应用程序到最大的Web和企业应用程序。Shiro提供了应用程序安全API来执行以下方面： 身份验证 - 证明用户身份，通常称为用户“登录”。 授权 - 访问控制 密码学 - 保护或隐藏窥探数据的数据 会话管理 - 每用户时间敏感状态]]></content>
      <categories>
        <category>Web后端技术</category>
        <category>【Shiro学习】</category>
      </categories>
      <tags>
        <tag>安全框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA创建第一个maven-web项目]]></title>
    <url>%2F2019%2F06%2F18%2FIntellij-IDEA%2Fidea%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AAmaven-web%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[IDEA创建WEB项目 用惯了eclipse，这段时间刚接触Idea编辑工具，这款神器是真的好用，兄弟们用起来!!! 但在创建maven web项目的一些步骤有些不熟悉，在这里介绍一下常用的maven web项目的创建过程。 1.步骤一：首先先创建一个project,在这里就是创建一个maven的工作空间 2.步骤二：选择左边的maven，然后在右边Creater from archetype选项前面打个勾,并且选择(maven-archetype-webapp),接着点击next 3.步骤三：填写你的Group Id（一般写公司名）跟 ArtifictId（一般写项目名） 4.步骤四：选择自己下载好的apache-maven. 5.步骤五：继续一路finish，等待idea加载出目录结构 如果目录没有出来，则点击更新操作。 6.步骤六：项目的基本目录结构出来后,我们还需为项目配置下编译路径还有artifact，操作如下 7.步骤七：配置tomcat本地服务器，运行项目]]></content>
      <categories>
        <category>Intellij IDEA</category>
      </categories>
      <tags>
        <tag>编辑器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[逆向工程在idea开发项目的使用]]></title>
    <url>%2F2019%2F06%2F18%2FWeb%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%2F%E5%B7%A5%E7%A8%8B%E6%8A%80%E6%9C%AF-%E3%80%90%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E3%80%91%2F%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E5%9C%A8idea%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[逆向工程技术的使用一、逆向工程 逆向工程：mybaits需要程序员自己编写sql语句，编写过程比较繁琐。因此mybatis官方提供逆向工程mybatis-generator,可以根据表与表之间的关系，自动生成mybatis执行所需要的代码（mapper.java,mapper.xml,pojo） 二、逆向工程的准备1.建立一个数据库表（你要操作的） 2.jar包准备（pom.xml引入依赖包，下面引入包比较多，可根据需要引入）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.yy&lt;/groupId&gt; &lt;artifactId&gt;YYcoder&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;YYcoder Maven Webapp&lt;/name&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;spring.version&gt;4.1.4.RELEASE&lt;/spring.version&gt; &lt;jackson.version&gt;2.5.0&lt;/jackson.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!-- junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- spring 所有核心包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- mybatis 包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.2.8&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis spring 整合 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql连接 注意版本--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据源 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.12&lt;/version&gt; &lt;/dependency&gt; &lt;!-- aspectjweaver是spring的切入点表达式需要用的包， --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log4j --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;!-- servlet --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;3.0-alpha-1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- jstl --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- java对象和json相互转化 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt; &lt;version&gt;1.9.13&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 后台转化为json格式 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- springmvc框架整合AJAX使用@ResponseBody需要此包 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 基本的序列化和反序列化 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 将JSON格式的数据转化为类对象 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;$&#123;jackson.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 文件上传 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis-generator-core 反向生成java代码--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 文件上传 --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis-redis整合依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt; &lt;artifactId&gt;mybatis-redis&lt;/artifactId&gt; &lt;version&gt;1.0.0-beta2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring 整合 redis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt; &lt;version&gt;1.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- jedis 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;YYcoder&lt;/finalName&gt; &lt;plugins&gt; &lt;!-- 资源文件拷贝插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;2.7&lt;/version&gt; &lt;configuration&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- java编译插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.2&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!-- 配置Tomcat插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;uriEncoding&gt;UTF-8&lt;/uriEncoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;!--逆向工程插件--&gt; &lt;!-- mybatis generator 自动生成代码插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.5&lt;/version&gt; &lt;configuration&gt; &lt;!-- 配置文件路径 --&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt;&lt;/project&gt; 3.编写generatorConfig.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot; &gt;&lt;generatorConfiguration &gt; &lt;!-- mysql jar 文件位置 --&gt; &lt;context id=&quot;store&quot; targetRuntime=&quot;MyBatis3&quot;&gt; &lt;commentGenerator&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name=&quot;suppressAllComments&quot; value=&quot;true&quot; /&gt; &lt;!-- 是否去除所有自动生成的文件的时间戳，默认为false --&gt; &lt;property name=&quot;suppressDate&quot; value=&quot;true&quot;/&gt; &lt;/commentGenerator&gt; &lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/yy_mysql&quot; userId=&quot;root&quot; password=&quot;cyy493610&quot;&gt; &lt;/jdbcConnection&gt; &lt;!-- targetPackage:包名称(自定义) targetProject：项目路径(自定义) --&gt; &lt;!--定义model的包名称--&gt; &lt;javaModelGenerator targetPackage=&quot;com.YYcoder.entity&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;!-- 从数据库返回的值被清理前后的空格 --&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt; &lt;/javaModelGenerator&gt; &lt;!-- 配置生成相应的实体Mapper.xml，对于Mapper3.X我们需要把type=&quot;XMLMAPPER&quot; --&gt; &lt;!-- targetPackage:包名称(自定义) targetProject：项目路径(自定义) --&gt; &lt;sqlMapGenerator targetPackage=&quot;com.YYcoder.mapper&quot; targetProject=&quot;src/main/java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 配置生成相应的接口类，对应与Mapper.xml中的一系列CRUD方法SQL语句 --&gt; &lt;!-- targetPackage:包名称(自定义) targetProject：项目路径(自定义) --&gt; &lt;javaClientGenerator targetPackage=&quot;com.YYcoder.mapper&quot; targetProject=&quot;src/main/java&quot; type=&quot;XMLMAPPER&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;false&quot; /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 数据库表名 --&gt; &lt;!-- 取消生成example类--&gt; &lt;table tableName= &quot;address&quot; enableCountByExample=&quot;false&quot; enableUpdateByExample=&quot;false&quot; enableDeleteByExample=&quot;false&quot; enableSelectByExample=&quot;false&quot; selectByExampleQueryId=&quot;false&quot;&gt;&lt;/table&gt; &lt;table tableName= &quot;admin&quot; &gt;&lt;/table&gt; &lt;table tableName= &quot;category&quot; &gt;&lt;/table&gt; &lt;table tableName= &quot;goods&quot; &gt;&lt;/table&gt; &lt;table tableName= &quot;imagepath&quot; &gt;&lt;/table&gt; &lt;table tableName= &quot;order&quot; &gt;&lt;/table&gt; &lt;table tableName= &quot;oderitem&quot; &gt;&lt;/table&gt; &lt;table tableName= &quot;shop&quot; &gt;&lt;/table&gt; &lt;table tableName= &quot;shopcart&quot; &gt;&lt;/table&gt; &lt;table tableName= &quot;user&quot; &gt;&lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 4.编写测试类MyGenerator.java,运行生成对应的文件123456789101112131415161718192021222324252627282930313233package com.YYcoder.Test;import org.mybatis.generator.api.MyBatisGenerator;import org.mybatis.generator.config.Configuration;import org.mybatis.generator.config.xml.ConfigurationParser;import org.mybatis.generator.internal.DefaultShellCallback;import java.io.File;import java.util.ArrayList;import java.util.List;//编写java启动类，执行逆向工程的配置文件，生成数据库中指定表的model和dao层：// （注意：启动类中创建File中的路径是从本项目中开始的，需要找到从项目开始写起，直到找到配置文件的路径即可）public class MyGenerator &#123; public void generate() throws Exception &#123; List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true; File configFile = new File(&quot;./src/main/resources/generatorConfig.xml&quot;); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null); &#125; public static void main(String[] args) throws Exception &#123; try &#123; MyGenerator myGenerator = new MyGenerator(); myGenerator.generate(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 5.运行后，相应的包会出现对应的文件，即为操作成功]]></content>
      <categories>
        <category>Web后端技术</category>
        <category>工程技术--【逆向工程】</category>
      </categories>
      <tags>
        <tag>工程技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA并发--ReentrantLock部分源码分析]]></title>
    <url>%2F2019%2F05%2F16%2FJAVA%E5%B9%B6%E5%8F%91%2F%E3%80%90ReentrantLock%E3%80%91%2Fjava%E5%B9%B6%E5%8F%91-reentrantlock%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Java的内置锁一直都是备受争议的，在JDKJDK 1.6之前，synchronized这个重量级锁其性能一直都是较为低下，由此ReentrantLock诞生。sun公司也在1.6之后对sync进行大量的锁优化策略,但是与Lock相比synchronized还是存在一些缺陷的：虽然synchronized提供了便捷性的隐式获取锁释放锁机制（基于JVM机制），但是它却缺少了获取锁与释放锁的可操作性，可中断、超时获取锁，且它为独占式在高并发场景下性能大打折扣。如今，两者之间的性能差不多，具体取决于应用的场景。 怎么实现同步？1234567891011121314151617volatile int status=0;//标识---是否有线程在同步块-----是否有线程上锁成功void lock()&#123; while(!compareAndSet(0,1))&#123; //①自旋 //②yield+自旋 yield() //③sleep+自旋 sleep(100); &#125; //lock&#125;void unlock()&#123; //unlock即修改状态 status=0;&#125;boolean compareAndSet(int except,int newValue)&#123; //cas操作,修改status成功则返回true //比较并交换&#125; 1.自旋 缺点：耗费cpu资源。没有竞争到锁的线程会一直占用cpu资源进行cas操作。 解决思路：让得不到锁的线程让出CPU 2.yield+自旋 要解决自旋锁的性能问题必须让竞争锁失败的线程不空转,而是在获取不到锁的时候能把cpu资源给让出来，yield()方法就能让出cpu资源，当线程竞争锁失败时，会调用yield方法让出cpu。但是这种方法也存在一些问题，只有两个线程竞争锁时是有效的。当多个线程竞争时，由于该方法只是当前让出cpu，有可能操作系统下次还是选择运行该线程。 3.sleep+自旋 由于很难确定睡眠时间多少比较合适，太久可能会影响性能。比如A和B一起竞争，这里设置sleep(2000)睡2s,但是线程A只需1s就能完成，会造成资源白白浪费。 4.park+自旋 这种方法是调用了Unsafe类中的park方法，会将线程加入等待队列，等待唤醒，否则会永远沉睡。然后调用unpark()唤醒等待队列，实现线程的同步。（ReentrantLock就是利用了这种机制） ReentrankLock加锁分析AQS（AbstractQueuedSynchronizer）类1234567891011public abstract class AbstractQueuedSynchronizer&#123; private transient volatile Node head; //队首 private transient volatile Node tail;//尾 static final class Node&#123; volatile Node prev;//前指针 volatile Node next;//后指针 volatile Thread thread;//当前线程 volatile int waitStatus;//当该结点进入等待队列，将其前面的结点的状态改成-1，自身仍是0 &#125; private volatile int state;//锁状态，加锁成功则为1，重入+1 解锁则为0&#125; AQS的队列示意图 重要知识 锁对象：其实就是ReentrantLock的实例对象，下文应用代码第一行中的lock对象就是所谓的锁 自由状态：自由状态表示锁对象没有被别的线程持有，计数器为0 计数器：再lock对象中有一个字段state用来记录上锁次数，比如lock对象是自由状态则state为0，如果大于零则表示被线程持有了，当然也有重入那么state则&gt;1 waitStatus：仅仅是一个状态而已；ws是一个过渡状态，在不同方法里面判断ws的状态做不同的处理，所以ws=0有其存在的必要性 tail：队列的队尾 head：队列的对首 ts：第二个给lock加锁的线程 tf：第一个给lock加锁的线程 tc：当前给线程加锁的线程 tl：最后一个加锁的线程 tn：随便某个线程 当然这些线程有可能重复，比如第一次加锁的时候tf=tc=tl=tn 节点：就是上面的Node类的对象，里面封装了线程，所以某种意义上node就等于一个线程 简单示例123456789101112131415161718192021222324public class MyReentrantLock&#123; //默认是非公平锁。可通过boolean类型参数指定锁的类型 final ReentrantLock lock = new ReentrantLock(true); public static void mian()&#123; Thread t1= new Thread(&quot;t1&quot;)&#123; @Override public void run() &#123; doWork(); &#125; &#125;; t1.start(); &#125;; public static void doWork() &#123; System.out.print(Thread.currentThread().getName()); reentrantLock.lock(); try&#123; Thread.sleep(1000); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; reentrantLock.unlock(); &#125;&#125; Nofair/Fair方法1234567891011公平锁的lock方法final void lock() &#123; acquire(1);//1------标识加锁成功之后改变的值&#125;非公平锁的lockfinal void lock() &#123; if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1);&#125; 执行逻辑图 公平锁的上锁是必须判断自己是不是需要排队,而非公平锁是直接进行CAS修改计数器看能不能加锁成功.如果加锁不成功则乖乖排队(调用acquire),所以不管公平还是不公平,只要进到了AQS队列当中那么他就会排队. 主要方法源码剖析acquire()方法源码 acquire方法首先会调用tryAcquire方法，注意tryAcquire的结果做了取反12345678public final void acquire(int arg) &#123; //tryAcquire(arg)尝试加锁，如果加锁失败则会调用acquireQueued方法加入队列去排队，如果加锁成功则不会调用 //acquireQueued方法下文会有解释 //加入队列之后线程会立马park，等到解锁之后会被unpark，醒来之后判断自己是否被打断了 if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; tryAcquire()方法源码12345678910111213141516171819202122232425262728protected final boolean tryAcquire(int acquires) &#123; //获取当前线程 final Thread current = Thread.currentThread(); //获取lock对象的上锁状态，如果锁是自由状态则=0，如果被上锁则为1，大于1表示重入 int c = getState(); if (c == 0) &#123;//没人占用锁---&gt;我要去上锁----1、锁是自由状态 //hasQueuedPredecessors，判断自己是否需要排队这个方法比较复杂， //下面我会单独介绍，如果不需要排队则进行cas尝试加锁，如果加锁成功则把当前线程设置为拥有锁的线程 //继而返回true if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; //设置当前线程为拥有锁的线程，方面后面判断是不是重入（只需把这个线程拿出来判断是否当前线程即可判断重入） setExclusiveOwnerThread(current); return true; &#125; &#125; //如果C不等于0，而且当前线程不等于拥有锁的线程则不会进else if 直接返回false，加锁失败 //如果C不等于0，但是当前线程等于拥有锁的线程则表示这是一次重入，那么直接把状态+1表示重入次数+1 //那么这里也侧面说明了reentrantlock是可以重入的，因为如果是重入也返回true，也能lock成功 else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) throw new Error(&quot;Maximum lock count exceeded&quot;); setState(nextc); return true; &#125; return false;&#125; hasQueuedPredecessors()方法 如果整个方法如果最后返回false，则去加锁，如果返回true则不加锁，因为这个方法被取反了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293public final boolean hasQueuedPredecessors() &#123; Node t = tail; Node h = head; Node s; /** * 下面提到的所有不需要排队，并不是字面意义，我实在想不出什么词语来描述这个“不需要排队”；不需要排队有两种情况 * 一：队列没有初始化，不需要排队，不需要排队，不需要排队；直接去加锁，但是可能会失败；为什么会失败呢？ * 假设两个线程同时来lock，都看到队列没有初始化，都认为不需要排队，都去进行CAS修改计数器；有一个必然失败 * 比如t1先拿到锁，那么另外一个t2则会CAS失败，这个时候t2就会去初始化队列，并排队 * * 二：队列被初始化了，但是tc过来加锁，发觉队列当中第一个排队的就是自己；比如重入； * 那么什么叫做第一个排队的呢？下面解释了，很重要往下看； * 这个时候他也不需要排队，不需要排队，不需要排队；为什么不需要排对？ * 因为队列当中第一个排队的线程他会去尝试获取一下锁，因为有可能这个时候持有锁锁的那个线程可能释放了锁； * 如果释放了就直接获取锁执行。但是如果没有释放他就会去排队， * 所以这里的不需要排队，不是真的不需要排队 * * h != t 判断首不等于尾这里要分三种情况 * 1、队列没有初始化，也就是第一个线程tf来加锁的时候那么这个时候队列没有初始化， * h和t都是null，那么这个时候判断不等于则不成立（false）那么由于是&amp;&amp;运算后面的就不会走了， * 直接返回false表示不需要排队，而前面又是取反（if (!hasQueuedPredecessors()），所以会直接去cas加锁。 * ----------第一种情况总结：队列没有初始化没人排队，那么我直接不排队，直接上锁；合情合理、有理有据令人信服； * 好比你去火车站买票，服务员都闲的蛋疼，整个队列都没有形成；没人排队，你直接过去交钱拿票 * * 2、队列被初始化了，后面会分析队列初始化的流程，如果队列被初始化那么h!=t则成立；（不绝对，还有第3中情况） * h != t 返回true；但是由于是&amp;&amp;运算，故而代码还需要进行后续的判断 * （有人可能会疑问，比如队列初始化了；里面只有一个数据，那么头和尾都是同一个怎么会成立呢？ * 其实这是第3种情况--对头等于对尾；但是这里先不考虑，我们假设现在队列里面有大于1个数据） * 大于1个数据则成立;继续判断把h.next赋值给s；s有是对头的下一个Node， * 这个时候s则表示他是队列当中参与排队的线程而且是排在最前面的； * 为什么是s最前面不是h嘛？诚然h是队列里面的第一个，但是不是排队的第一个；下文有详细解释 * 因为h也就是对头对应的Node对象或者线程他是持有锁的，但是不参与排队； * 这个很好理解，比如你去买车票，你如果是第一个这个时候售票员已经在给你服务了，你不算排队，你后面的才算排队； * 队列里面的h是不参与排队的这点一定要明白；参考下面关于队列初始化的解释； * 因为h要么是虚拟出来的节点，要么是持有锁的节点；什么时候是虚拟的呢？什么时候是持有锁的节点呢？下文分析 * 然后判断s是否等于空，其实就是判断队列里面是否只有一个数据； * 假设队列大于1个，那么肯定不成立（s==null----&gt;false），因为大于一个Node的时候h.next肯定不为空； * 由于是||运算如果返回false，还要判断s.thread != Thread.currentThread()；这里又分为两种情况 * 2.1 s.thread != Thread.currentThread() 返回true，就是当前线程不等于在排队的第一个线程s； * 那么这个时候整体结果就是h!=t：true; （s==null false || s.thread != Thread.currentThread() true 最后true） * 结果： true &amp;&amp; true 方法最终放回true，所以需要去排队 * 其实这样符合情理，试想一下买火车票，队列不为空，有人在排队； * 而且第一个排队的人和现在来参与竞争的人不是同一个，那么你就乖乖去排队 * 2.2 s.thread != Thread.currentThread() 返回false 表示当前来参与竞争锁的线程和第一个排队的线程是同一个线程 * 这个时候整体结果就是h!=t----&gt;true; （s==null false || s.thread != Thread.currentThread() false-----&gt; 最后false） * 结果：true &amp;&amp; false 方法最终放回false，所以不需要去排队 * 不需要排队则调用 compareAndSetState(0, acquires) 去改变计数器尝试上锁； * 这里又分为两种情况（日了狗了这一行代码；有同学课后反应说子路老师老师老是说这个AQS难， * 你现在仔细看看这一行代码的意义，真的不简单的） * 2.2.1 第一种情况加锁成功？有人会问为什么会成功啊，如这个时候h也就是持有锁的那个线程执行完了 * 释放锁了，那么肯定成功啊；成功则执行 setExclusiveOwnerThread(current); 然后返回true 自己看代码 * 2.2.2 第二种情况加锁失败？有人会问为什么会失败啊。假如这个时候h也就是持有锁的那个线程没执行完 * 没释放锁，那么肯定失败啊；失败则直接返回false，不会进else if（else if是相对于 if (c == 0)的） * 那么如果失败怎么办呢？后面分析； * *----------第二种情况总结，如果队列被初始化了，而且至少有一个人在排队那么自己也去排队；但是有个插曲； * ----------他会去看看那个第一个排队的人是不是自己，如果是自己那么他就去尝试加锁；尝试看看锁有没有释放 *----------也合情合理，好比你去买票，如果有人排队，那么你乖乖排队，但是你会去看第一个排队的人是不是你女朋友； *----------如果是你女朋友就相当于是你自己（这里实在想不出现实世界关于重入的例子，只能用男女朋友来替代）； * --------- 你就叫你女朋友看看售票员有没有搞完，有没有轮到你女朋友，因为你女朋友是第一个排队的 * 疑问：比如如果在在排队，那么他是park状态，如果是park状态，自己怎么还可能重入啊。 * 希望有同学可以想出来为什么和我讨论一下，作为一个菜逼，希望有人教教我 * * * 3、队列被初始化了，但是里面只有一个数据；什么情况下才会出现这种情况呢？ts加锁的时候里面就只有一个数据？ * 其实不是，因为队列初始化的时候会虚拟一个h作为头结点，tc=ts作为第一个排队的节点；tf为持有锁的节点 * 为什么这么做呢？因为AQS认为h永远是不排队的，假设你不虚拟节点出来那么ts就是h， * 而ts其实需要排队的，因为这个时候tf可能没有执行完，还持有着锁，ts得不到锁，故而他需要排队； * 那么为什么要虚拟为什么ts不直接排在tf之后呢，上面已经时说明白了，tf来上锁的时候队列都没有，他不进队列， * 故而ts无法排在tf之后，只能虚拟一个thread=null的节点出来（Node对象当中的thread为null）； * 那么问题来了；究竟什么时候会出现队列当中只有一个数据呢？假设原队列里面有5个人在排队，当前面4个都执行完了 * 轮到第五个线程得到锁的时候；他会把自己设置成为头部，而尾部又没有，故而队列当中只有一个h就是第五个 * 至于为什么需要把自己设置成头部；其实已经解释了，因为这个时候五个线程已经不排队了，他拿到锁了； * 所以他不参与排队，故而需要设置成为h；即头部；所以这个时间内，队列当中只有一个节点 * 关于加锁成功后把自己设置成为头部的源码，后面会解析到；继续第三种情况的代码分析 * 记得这个时候队列已经初始化了，但是只有一个数据，并且这个数据所代表的线程是持有锁 * h != t false 由于后面是&amp;&amp;运算，故而返回false可以不参与运算，整个方法返回false；不需要排队 * * *-------------第三种情况总结：如果队列当中只有一个节点，而这种情况我们分析了， *-------------这个节点就是当前持有锁的那个节点，故而我不需要排队，进行cas；尝试加锁 *-------------这是AQS的设计原理，他会判断你入队之前，队列里面有没有人排队； *-------------有没有人排队分两种情况；队列没有初始化，不需要排队 *--------------队列初始化了，按时只有一个节点，也是没人排队，自己先也不排队 *--------------只要认定自己不需要排队，则先尝试加锁；加锁失败之后再排队； *--------------再一次解释了不需要排队这个词的歧义性 *-------------如果加锁失败了，在去park，下文有详细解释这样设计源码和原因 *-------------如果持有锁的线程释放了锁，那么我能成功上锁 * **/ return h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread());&#125; acquireQueued(addWaiter(Node.exclusive),arg))方法解析 如果代码能执行到这里说tc需要排队需要排队有两种情况—换言之代码能够执行到这里有两种情况：1、tf持有了锁，并没有释放，所以tc来加锁的时候需要排队，但这个时候—队列并没有初始化2、tn(无所谓哪个线程，反正就是一个线程)持有了锁，那么由于加锁tn!=tf(tf是属于第一种情况，我们现在不考虑tf了)，所以队列是一定被初始化了的，tc来加锁，那么队列当中有人在排队，故而他也去排队 addWaiter(Node.EXCLUSIVE)源码分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103private Node addWaiter(Node mode) &#123; //由于AQS队列当中的元素类型为Node，故而需要把当前线程tc封装成为一个Node对象,下文我们叫做nc Node node = new Node(Thread.currentThread(), mode); //tail为对尾，赋值给pred Node pred = tail; //判断pred是否为空，其实就是判断对尾是否有节点，其实只要队列被初始化了对尾肯定不为空， //假设队列里面只有一个元素，那么对尾和对首都是这个元素 //换言之就是判断队列有没有初始化 //上面我们说过代码执行到这里有两种情况，1、队列没有初始化和2、队列已经初始化了 //pred不等于空表示第二种情况，队列被初始化了，如果是第二种情况那比较简单 //直接把当前线程封装的nc的上一个节点设置成为pred即原来的对尾 //继而把pred的下一个节点设置为当nc，这个nc自己成为对尾了 if (pred != null) &#123; //直接把当前线程封装的nc的上一个节点设置成为pred即原来的对尾，对应 10行的注释 node.prev = pred; //这里需要cas，因为防止多个线程加锁，确保nc入队的时候是原子操作 if (compareAndSetTail(pred, node)) &#123; //继而把pred的下一个节点设置为当nc，这个nc自己成为对尾了 对应第11行注释 pred.next = node; //然后把nc返回出去，方法结束 return node; &#125; &#125; //如果上面的if不成了就会执行到这里，表示第一种情况队列并没有初始化---下面解析这个方法 enq(node); //返回nc return node;&#125;private Node enq(final Node node) &#123;//这里的node就是当前线程封装的node也就是nc //死循环 for (;;) &#123; //对尾复制给t，上面已经说过队列没有初始化， //故而第一次循环t==null（因为是死循环，因此强调第一次，后面可能还有第二次、第三次，每次t的情况肯定不同） Node t = tail; //第一次循环成了成立 if (t == null) &#123; // Must initialize //new Node就是实例化一个Node对象下文我们称为nn， //调用无参构造方法实例化出来的Node里面三个属性都为null，可以关联Node类的结构， //compareAndSetHead入队操作；把这个nn设置成为队列当中的头部，cas防止多线程、确保原子操作； //记住这个时候队列当中只有一个，即nn if (compareAndSetHead(new Node())) //这个时候AQS队列当中只有一个元素，即头部=nn，所以为了确保队列的完整，设置头部等于尾部，即nn即是头也是尾 //然后第一次循环结束；接着执行第二次循环，第二次循环代码我写在了下面，接着往下看就行 tail = head; &#125; else &#123; node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125;&#125;//为了方便 第二次循环我再贴一次代码来对第二遍循环解释private Node enq(final Node node) &#123;//这里的node就是当前线程封装的node也就是nc //死循环 for (;;) &#123; //对尾复制给t，由于第二次循环，故而tail==nn，即new出来的那个node Node t = tail; //第二次循环不成立 if (t == null) &#123; // Must initialize if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; //不成立故而进入else //首先把nc，当前线程所代表的的node的上一个节点改变为nn，因为这个时候nc需要入队，入队的时候需要把关系维护好 //所谓的维护关系就是形成链表，nc的上一个节点只能为nn，这个很好理解 node.prev = t; //入队操作--把nc设置为对尾，对首是nn， if (compareAndSetTail(t, node)) &#123; //上面我们说了为了维护关系把nc的上一个节点设置为nn //这里同样为了维护关系，把nn的下一个节点设置为nc t.next = node; //然后返回t，即nn，死循环结束，enq(node);方法返回 //这个返回其实就是为了终止循环，返回出去的t，没有意义 return t; &#125; &#125; &#125;&#125; //这个方法已经解释完成了 enq(node); //返回nc，不管哪种情况都会返回nc；到此addWaiter方法解释完成 return node;//再次贴出node的结构方便大家查看public class Node&#123; volatile Node prev; volatile Node next; volatile Thread thread;&#125;-------------------总结：addWaiter方法就是让nc入队-并且维护队列的链表关系，但是由于情况复杂做了不同处理-------------------主要针对队列是否有初始化，没有初始化则new一个新的Node nn作为对首，nn里面的线程为null-------------------接下来分析acquireQueued方法 acquireQueued方法的源码分析12345678910111213141516171819202122232425262728protected final boolean tryAcquire(int acquires) &#123; //获取当前线程 final Thread current = Thread.currentThread(); //获取lock对象的上锁状态，如果锁是自由状态则=0，如果被上锁则为1，大于1表示重入 int c = getState(); if (c == 0) &#123;//没人占用锁---&gt;我要去上锁----1、锁是自由状态 //hasQueuedPredecessors，判断自己是否需要排队这个方法比较复杂， //下面我会单独介绍，如果不需要排队则进行cas尝试加锁，如果加锁成功则把当前线程设置为拥有锁的线程 //继而返回true if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; //设置当前线程为拥有锁的线程，方面后面判断是不是重入（只需把这个线程拿出来判断是否当前线程即可判断重入） setExclusiveOwnerThread(current); return true; &#125; &#125; //如果C不等于0，而且当前线程不等于拥有锁的线程则不会进else if 直接返回false，加锁失败 //如果C不等于0，但是当前线程等于拥有锁的线程则表示这是一次重入，那么直接把状态+1表示重入次数+1 //那么这里也侧面说明了reentrantlock是可以重入的，因为如果是重入也返回true，也能lock成功 else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) throw new Error(&quot;Maximum lock count exceeded&quot;); setState(nextc); return true; &#125; return false;&#125; 加锁过程总结：如果是第一个线程tf，那么和队列无关，线程直接持有锁。并且也不会初始化队列，如果接下来的线程都是交替执行，那么永远和AQS队列无关，都是直接线程持有锁。如果发生了竞争，比如tf持有锁的过程中T2来lock，那么这个时候就会初始化AQS，初始化AQS的时候会在队列的头部虚拟一个Thread为NULL的Node，因为队列当中的head永远是持有锁的那个node（除了第一次会虚拟一个，其他时候都是持有锁的那个线程锁封装的node），现在第一次的时候持有锁的是tf而tf不在队列当中所以虚拟了一个node节点，队列当中的除了head之外的所有的node都在park，当tf释放锁之后unpark某个（基本是队列当中的第二个，为什么是第二个呢？前面说过head永远是持有锁的那个node，当有时候也不会是第二个，比如第二个被cancel之后，至于为什么会被cancel，不在我们讨论范围之内，cancel的条件很苛刻，基本不会发生）node之后，node被唤醒，假设node是t2，那么这个时候会首先把t2变成head（sethead），在sethead方法里面会把t2代表的node设置为head，并且把node的Thread设置为null，为什么需要设置null？其实原因很简单，现在t2已经拿到锁了，node就不要排队了，那么node对Thread的引用就没有意义了。所以队列的head里面的Thread永远为null]]></content>
      <categories>
        <category>JAVA并发</category>
        <category>【ReentrantLock】</category>
      </categories>
      <tags>
        <tag>框架学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA并发--synchronized]]></title>
    <url>%2F2019%2F05%2F16%2FJAVA%E5%B9%B6%E5%8F%91%2F%E3%80%90synchronized%E3%80%91%2Fjava%E5%B9%B6%E5%8F%91-synchronized%2F</url>
    <content type="text"><![CDATA[synchronizedsync锁住的是对象，并不是代码。对象包含 对象头，对象的实例数据，对齐字节实例对象是8的倍数对象的状态无锁偏向锁轻量锁重量锁GC标记 org.openjdk.jol 可以打印对象实例 ClassLayout.parseInstance().toPrintable jol-core对象头12字节。96位bitopenjdk是源码，jvm规范 jvm是个概念/标准，hotspot是sun开发的产品/落地的实现openjdk是源码，jvm规范 每个对象都必须要有对象头hotspot中的对象头由Mark Word(64bit)和klass pointer(Class Metedata Address,可以也是64bit,但是指针进行了压缩，现在只要32bit。oop to the metedata Object)两个属性组成.对象头包含对象的布局、类型、GC状态、同步状态、标识哈希码对象头使用 小端存储模式 大端存储 unused:25 hash:31 unused:1 age:4 (偏向锁)biased_lock:1 lock:2偏向锁 thread标识：54 epoch:2 unused:1 age:4 biased_lock:1 lock:2sync thread.start() 调用native本地方法start0 调用操作系统mutex实现同步互斥 用户态转为内核态，性能低下1.6之后进行了优化 没有资源竞争|单个线程 同步代码-偏向锁，一个线程调用 有多个线程执行 多个线程交替执行 多个线程同时进行]]></content>
      <categories>
        <category>JAVA并发</category>
        <category>【synchronized】</category>
      </categories>
      <tags>
        <tag>框架学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot(一)：入门篇]]></title>
    <url>%2F2019%2F05%2F16%2FWeb%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%2F%E3%80%90SpringBoot%E5%AD%A6%E4%B9%A0%E3%80%91%2Fspring-boot-%E4%B8%80-%EF%BC%9A%E5%85%A5%E9%97%A8%E7%AF%87%2F</url>
    <content type="text"><![CDATA[构建微服务：Spring boot 入门篇什么是Spring Boot?Spring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。其实Spring Boot 不是什么新的框架，它只是默认配置了很多框架的使用方式，就像 Maven 整合了所有的 Jar 包，Spring Boot 整合了所有的框架。 使用 Spring Boot有什么好处其实就是简单、快速、方便！平时如果我们需要搭建一个 Spring Web 项目的时候需要怎么做呢？ 1）配置 web.xml，加载 Spring 和 Spring mvc 2）配置数据库连接、配置 Spring 事务 3）配置加载配置文件的读取，开启注解 4）配置日志文件 ···· 配置完成之后部署 Tomcat 调试想象一下如果生产项目，只是为了实现简单的一个发送消息的功能，都需要这样折腾一遍! 但是如果使用 Spring Boot 呢？ 很简单，我仅仅只需要非常少的几个配置就可以迅速方便的搭建起来一套 Web 项目或者是构建一个微服务！ 快速入门 说了那么多，不如马上来动手试一试! Maven 构建项目 1、访问 http://start.spring.io/ 2、选择构建工具 Maven Project、Java、Spring Boot 版本 2.1.5 以及一些工程基本信息，可参考下图 所示： 3、点击 Generate Project 下载项目压缩包 4、解压后，使用 Idea 导入项目，File -&gt; New -&gt; Model from Existing Source.. -&gt; 选择解压后的文件夹 -&gt; OK，选择 Maven 一路 Next，OK done! 5、如果使用的是 Eclipse，Import -&gt; Existing Maven Projects -&gt; Next -&gt; 选择解压后的文件夹 -&gt; Finsh，OK done! Idea 构建项目 1、选择 File -&gt; New —&gt; Project… 弹出新建项目的框 2、选择 Spring Initializr，Next 也会出现上述类似的配置界面，Idea 帮我们做了集成 3、填写相关内容后，点击 Next 选择依赖的包再点击 Next，最后确定信息无误点击 Finish。 项目结构介绍 如上图所示，Spring Boot的基础结构共三个文件: src/main/java 程序开发以及主程序入口 src/main/resources 配置文件 src/test/java 测试程序 另外，spingboot建议的目录结果如下： root package结构：com.example.myproject 123456789101112131415com +- example +- myproject +- Application.java | +- domain | +- Customer.java | +- CustomerRepository.java | +- service | +- CustomerService.java | +- controller | +- CustomerController.java | 1、Application.java 建议放到跟目录下面,主要用于做一些框架配置 2、domain目录主要用于实体（Entity）与数据访问层（Repository） 3、service 层主要是业务类代码 4、controller 负责页面访问控制 采用默认配置可以省去很多配置，当然也可以根据自己的喜欢来进行更改最后，启动Application main方法，至此一个java项目搭建好了！ 引入 Web 模块1、pom.xml中添加支持web的模块：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; pom.xml文件中默认有两个模块： spring-boot-starter：核心模块，包括自动配置支持、日志和YAML； spring-boot-starter-test：测试模块，包括JUnit、Hamcrest、Mockito。 2、编写controller内容1234567@RestControllerpublic class HelloWorldController &#123; @RequestMapping(&quot;/hello&quot;) public String index() &#123; return &quot;Hello World&quot;; &#125;&#125; @RestController的意思就是controller里面的方法都以json格式输出，不用再写什么jackjson配置的了！ 3、启动主程序，打开浏览器访问http://localhost:8080/hello, 就可以看到效果了，是不是很简单粗暴！ 如何做单元测试打开的src/test/下的测试入口，编写简单的http请求来测试；使用mockmvc进行，利用MockMvcResultHandlers.print() 打印出执行结果。1234567891011121314151617 @RunWith(SpringRunner.class) @SpringBootTest public class HelloWorldControlerTests &#123; private MockMvc mvc; @Before public void setUp() throws Exception &#123; mvc = MockMvcBuilders.standaloneSetup(new HelloWorldController()).build(); &#125; @Test public void getHello() throws Exception &#123; mvc.perform(MockMvcRequestBuilders.get(&quot;/hello&quot;).accept(MediaType.APPLICATION_JSON)) .andExpect(MockMvcResultMatchers.status().isOk()) .andDo(MockMvcResultHandlers.print()) .andReturn(); &#125;&#125; 开发环境的调试热启动在正常开发项目中已经很常见了吧，虽然平时开发 web 项目过程中，改动项目启重启总是报错；但Spring Boot对调试支持很好，修改之后可以实时生效，需要添加以下的配置： 1234567891011121314151617181920212223242526272829303132333435&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 该模块在完整的打包环境下运行的时候会被禁用。如果你使用java -jar启动应用或者用一个特定的classloader启动，它会认为这是一个“生产环境”。 总结使用 Spring Boot 可以非常方便、快速搭建项目，使我们不用关心框架之间的兼容性，适用版本等各种问题，我们想使用任何东西，仅仅添加一个配置就可以，所以使用 Spring Boot 非常适合构建微服务。]]></content>
      <categories>
        <category>Web后端技术</category>
        <category>【SpringBoot学习】</category>
      </categories>
      <tags>
        <tag>框架学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法(一)--冒泡排序]]></title>
    <url>%2F2019%2F05%2F16%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%2F%E3%80%90%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E3%80%91%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E4%B8%80-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[冒泡排序（每趟排序过程中通过两两比较，找到第 i 个小（大）的元素，将其往上排。） 算法概念比较相邻的元素。如果第一个比第二个大，就交换他们两个。针对所有的元素重复以上的步骤，除了最后一个。持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 冒泡排序动画演示 冒泡排序冒泡排序是一种交换排序。 什么是交换排序呢？ 交换排序：两两比较待排序的关键字，并交换不满足次序要求的那对数，直到整个表都满足次序要求为止。 算法思想 它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。 假设有一个大小为 N 的无序序列。冒泡排序就是要每趟排序过程中通过两两比较，找到第 i 个小（大）的元素，将其往上排。 图-冒泡排序示例图 以上图为例，演示一下冒泡排序的实际流程：假设有一个无序序列 { 4. 3. 1. 2, 5 }第一趟排序：通过两两比较，找到第一小的数值 1 ，将其放在序列的第一位。第二趟排序：通过两两比较，找到第二小的数值 2 ，将其放在序列的第二位。第三趟排序：通过两两比较，找到第三小的数值 3 ，将其放在序列的第三位。至此，所有元素已经有序，排序结束。 要将以上流程转化为代码，我们需要像机器一样去思考，不然编译器可看不懂。假设要对一个大小为 N 的无序序列进行升序排序（即从小到大）。(1) 每趟排序过程中需要通过比较找到第 i 个小的元素。所以，我们需要一个外部循环，从数组首端(下标 0) 开始，一直扫描到倒数第二个元素（即下标 N - 2) ，剩下最后一个元素，必然为最大。(2) 假设是第 i 趟排序，可知，前 i-1 个元素已经有序。现在要找第 i 个元素，只需从数组末端开始，扫描到第 i 个元素，将它们两两比较即可。所以，需要一个内部循环，从数组末端开始（下标 N - 1），扫描到 (下标 i + 1)。 核心代码 算法分析 冒泡排序算法的性能 时间复杂度若文件的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数C和记录移动次数M均达到最小值：Cmin = N - 1, Mmin = 0。所以，冒泡排序最好时间复杂度为O(N)。 若初始文件是反序的，需要进行 N -1 趟排序。每趟排序要进行 N - i 次关键字的比较(1 ≤ i ≤ N - 1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：Mmax = 3N(N-1)/2 = O(N2)冒泡排序的最坏时间复杂度为O(N2)。因此，冒泡排序的平均时间复杂度为O(N2)。总结起来，其实就是一句话：当数据越接近正序时，冒泡排序性能越好。 算法稳定性冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。 优化对冒泡排序常见的改进方法是加入标志性变量exchange，用于标志某一趟排序过程中是否有数据交换。如果进行某一趟排序时并没有进行数据交换，则说明所有数据已经有序，可立即结束排序，避免不必要的比较过程。核心代码 运行结果12345678排序前： 2 9 9 7 1 9 0 2 6 8 第 0 趟： 0 2 9 9 7 1 9 2 6 8 第 1 趟： 0 1 2 9 9 7 2 9 6 8 第 2 趟： 0 1 2 2 9 9 7 6 9 8 第 3 趟： 0 1 2 2 6 9 9 7 8 9 第 4 趟： 0 1 2 2 6 7 9 9 8 9 第 5 趟： 0 1 2 2 6 7 8 9 9 9 排序后： 0 1 2 2 6 7 8 9 9 9]]></content>
      <categories>
        <category>数据结构和算法</category>
        <category>【排序算法】</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法(二)--选择排序]]></title>
    <url>%2F2019%2F05%2F16%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%2F%E3%80%90%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E3%80%91%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E4%BA%8C-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[算法概念首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。重复第二步，直到所有元素均排序完毕。 动画演示 选择排序动画演示 参考代码 排序算法总结简单选择排序是一种选择排序。 选择排序：每趟从待排序的记录中选出关键字最小的记录，顺序放在已排序的记录序列末尾，直到全部排序结束为止。 简单排序处理流程(1)从待排序序列中，找到关键字最小的元素；(2)如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；(3)从余下的 N - 1 个元素中，找出关键字最小的元素，重复(1)、(2)步，直到排序结束。如图所示，每趟排序中，将当前第 i 小的元素放在位置 i 上。核心代码1234567891011121314151617181920212223public void selectionSort(int[] list) &#123; // 需要遍历获得最小值的次数 // 要注意一点，当要排序 N 个数，已经经过 N-1 次遍历后，已经是有序数列 for (int i = 0; i &lt; list.length - 1; i++) &#123; int temp = 0; int index = i; // 用来保存最小值得索引 // 寻找第i个小的数值 for (int j = i + 1; j &lt; list.length; j++) &#123; if (list[index] &gt; list[j]) &#123; index = j; &#125; &#125; // 将找到的第i个小的数值放在第i个位置上 temp = list[index]; list[index] = list[i]; list[i] = temp; System.out.format(&quot;第 %d 趟: &quot;, i + 1); printAll(list); &#125;&#125; 算法分析 算法的性能 时间复杂度简单选择排序的比较次数与序列的初始排序无关。 假设待排序的序列有 N 个元素，则比较次数总是N (N - 1) / 2。而移动次数与序列的初始排序有关。当序列正序时，移动次数最少，为 0.当序列反序时，移动次数最多，为3N (N - 1) / 2。所以，综合以上，简单排序的时间复杂度为O(N2)。 空间复杂度简单选择排序需要占用 1 个临时空间，在交换数值时使用。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package notes.javase.algorithm.sort;import java.util.Random; public class SelectionSort &#123; public void selectionSort(int[] list) &#123; // 需要遍历获得最小值的次数 // 要注意一点，当要排序 N 个数，已经经过 N-1 次遍历后，已经是有序数列 for (int i = 0; i &lt; list.length - 1; i++) &#123; int temp = 0; int index = i; // 用来保存最小值得索引 // 寻找第i个小的数值 for (int j = i + 1; j &lt; list.length; j++) &#123; if (list[index] &gt; list[j]) &#123; index = j; &#125; &#125; // 将找到的第i个小的数值放在第i个位置上 temp = list[index]; list[index] = list[i]; list[i] = temp; System.out.format(&quot;第 %d 趟: &quot;, i + 1); printAll(list); &#125; &#125; // 打印完整序列 public void printAll(int[] list) &#123; for (int value : list) &#123; System.out.print(value + &quot; &quot;); &#125; System.out.println(); &#125; public static void main(String[] args) &#123; // 初始化一个随机序列 final int MAX_SIZE = 10; int[] array = new int[MAX_SIZE]; Random random = new Random(); for (int i = 0; i &lt; MAX_SIZE; i++) &#123; array[i] = random.nextInt(MAX_SIZE); &#125; // 调用冒泡排序方法 SelectionSort selection = new SelectionSort(); System.out.print(&quot;排序前: &quot;); selection.printAll(array); selection.selectionSort(array); System.out.print(&quot;排序后: &quot;); selection.printAll(array); &#125;&#125; 运行结果1234567891011排序前: 3 5 2 8 1 2 0 8 4 1 第 1 趟: 0 5 2 8 1 2 3 8 4 1 第 2 趟: 0 1 2 8 5 2 3 8 4 1 第 3 趟: 0 1 1 8 5 2 3 8 4 2 第 4 趟: 0 1 1 2 5 8 3 8 4 2 第 5 趟: 0 1 1 2 2 8 3 8 4 5 第 6 趟: 0 1 1 2 2 3 8 8 4 5 第 7 趟: 0 1 1 2 2 3 4 8 8 5 第 8 趟: 0 1 1 2 2 3 4 5 8 8 第 9 趟: 0 1 1 2 2 3 4 5 8 8 排序后: 0 1 1 2 2 3 4 5 8 8]]></content>
      <categories>
        <category>数据结构和算法</category>
        <category>【排序算法】</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法（三）--插入排序]]></title>
    <url>%2F2019%2F05%2F16%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%2F%E3%80%90%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E3%80%91%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%89%EF%BC%89-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[算法概念将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。） 动画演示插入排序动画演示 参考代码 算法总结直接插入排序是一种最简单的插入排序。 插入排序：每一趟将一个待排序的记录，按照其关键字的大小插入到有序队列的合适位置里，知道全部插入完成。 在讲解直接插入排序之前，先让我们脑补一下我们打牌的过程。先拿一张5在手里，再摸到一张4，比5小，插到5前面，摸到一张6，嗯，比5大，插到5后面，摸到一张8，比6大，插到6后面，。。。最后一看，我靠，凑到全是同花顺，这下牛逼大了。以上的过程，其实就是典型的直接插入排序，每次将一个新数据插入到有序队列中的合适位置里。 算法步骤假设有一组无序序列 R0, R1, … , RN-1。(1) 我们先将这个序列中下标为 0 的元素视为元素个数为 1 的有序序列。(2) 然后，我们要依次把 R1, R2, … , RN-1 插入到这个有序序列中。所以，我们需要一个外部循环，从下标 1 扫描到 N-1 。(3) 接下来描述插入过程。假设这是要将 Ri 插入到前面有序的序列中。由前面所述，我们可知，插入Ri时，前 i-1 个数肯定已经是有序了。所以我们需要将Ri 和R0 ~ Ri-1 进行比较，确定要插入的合适位置。这就需要一个内部循环，我们一般是从后往前比较，即从下标 i-1 开始向 0 进行扫描。 核心代码 算法分析 算法性能 时间复杂度1.当数据正序时，执行效率最好，每次插入都不用移动前面的元素，时间复杂度为O(N)。2.当数据反序时，执行效率最差，每次插入都要前面的元素后移，时间复杂度为O(N2)。3.所以，数据越接近正序，直接插入排序的算法性能越好。 空间复杂度由直接插入排序算法可知，我们在排序过程中，需要一个临时变量存储要插入的值，所以空间复杂度为 1 。 算法稳定性直接插入排序的过程中，不需要改变相等数值元素的位置，所以它是稳定的算法。 代码实现 运行结果]]></content>
      <categories>
        <category>数据结构和算法</category>
        <category>【排序算法】</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十大排序(四)--希尔排序]]></title>
    <url>%2F2019%2F05%2F16%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%2F%E3%80%90%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E3%80%91%2F%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F-%E5%9B%9B-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[算法概念希尔(Shell)排序又称为缩小增量排序，它是一种插入排序。它是直接插入排序算法的一种威力加强版。 算法思想把记录按步长 gap 分组，对每组记录采用直接插入排序方法进行排序。随着步长逐渐减小，所分成的组包含的记录越来越多，当步长的值减小到 1 时，整个数据合成为一组，构成一组有序记录，则完成排序。我们来通过演示图，更深入的理解一下这个过程。 在上面这幅图中：初始时，有一个大小为 10 的无序序列。 在第一趟排序中，我们不妨设 gap1 = N / 2 = 5，即相隔距离为 5 的元素组成一组，可以分为 5 组。接下来，按照直接插入排序的方法对每个组进行排序。 在第二趟排序中，我们把上次的 gap 缩小一半，即 gap2 = gap1 / 2 = 2 (取整数)。这样每相隔距离为 2 的元素组成一组，可以分为 2 组。按照直接插入排序的方法对每个组进行排序。 在第三趟排序中，再次把 gap 缩小一半，即gap3 = gap2 / 2 = 1。 这样相隔距离为 1 的元素组成一组，即只有一组。按照直接插入排序的方法对每个组进行排序。此时，排序已经结束。 需要注意一下的是，图中有两个相等数值的元素 5 和 5 。我们可以清楚的看到，在排序过程中，两个元素位置交换了。所以，希尔排序是不稳定的算法。 核心代码 算法分析 算法性能 时间复杂度步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。 算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为1进行排序。当步长为1时，算法变为插入排序，这就保证了数据一定会被排序。 Donald Shell 最初建议步长选择为N/2并且对步长取半直到步长达到1。虽然这样取可以比O(N2)类的算法（插入排序）更好，但这样仍然有减少平均时间和最差时间的余地。可能希尔排序最重要的地方在于当用较小步长排序后，以前用的较大步长仍然是有序的。比如，如果一个数列以步长5进行了排序然后再以步长3进行排序，那么该数列不仅是以步长3有序，而且是以步长5有序。如果不是这样，那么算法在迭代过程中会打乱以前的顺序，那就不会以如此短的时间完成排序了。已知的最好步长序列是由Sedgewick提出的(1, 5, 19, 41, 109,…)，该序列的项来自这两个算式。这项研究也表明“比较在希尔排序中是最主要的操作，而不是交换。”用这样步长序列的希尔排序比插入排序和堆排序都要快，甚至在小数组中比快速排序还快，但是在涉及大量数据时希尔排序还是比快速排序慢。 算法稳定性由上文的希尔排序算法演示图即可知，希尔排序中相等数据可能会交换位置，所以希尔排序是不稳定的算法。 直接插入排序和希尔排序的比较直接插入排序是稳定的；而希尔排序是不稳定的。直接插入排序更适合于原始记录基本有序的集合。希尔排序的比较次数和移动次数都要比直接插入排序少，当N越大时，效果越明显。在希尔排序中，增量序列gap的取法必须满足：最后一个步长必须是 1。直接插入排序也适用于链式存储结构；希尔排序不适用于链式结构。 代码实现范例代码中的初始序列和本文图示中的序列完全一致。 运行结果]]></content>
      <categories>
        <category>数据结构和算法</category>
        <category>【十大排序】</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法(五)--归并排序]]></title>
    <url>%2F2019%2F05%2F16%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%2F%E3%80%90%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E3%80%91%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E4%BA%94-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[算法概念归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。 归并排序的基本思想将待排序序列R[0…n-1]看成是n个长度为1的有序序列，将相邻的有序表成对归并，得到n/2个长度为2的有序表；将这些有序序列再次归并，得到n/4个长度为4的有序序列；如此反复进行下去，最后得到一个长度为n的有序序列。综上可知：归并排序其实要做两件事：（1）“分解”——将序列每次折半划分。（2）“合并”——将划分后的序列段两两合并后排序。我们先来考虑第二步，如何合并？在每次合并过程中，都是对两个有序的序列段进行合并，然后排序。这两个有序序列段分别为 R[low, mid] 和 R[mid+1, high]。先将他们合并到一个局部的暂存数组R2中，带合并完成后再将R2复制回R中。为了方便描述，我们称 R[low, mid] 第一段，R[mid+1, high] 为第二段。每次从两个段中取出一个记录进行关键字的比较，将较小者放入R2中。最后将各段中余下的部分直接复制到R2中。经过这样的过程，R2已经是一个有序的序列，再将其复制回R中，一次合并排序就完成了。 合并核心代码 掌握了合并的方法，接下来，让我们来了解 如何分解。 在某趟归并中，设各子表的长度为gap，则归并前R[0…n-1]中共有n/gap个有序的子表：R[0…gap-1], R[gap…2gap-1], … , R[(n/gap)gap … n-1]。调用Merge将相邻的子表归并时，必须对表的特殊情况进行特殊处理。若子表个数为奇数，则最后一个子表无须和其他子表归并（即本趟处理轮空）：若子表个数为偶数，则要注意到最后一对子表中后一个子表区间的上限为n-1。 分解核心代码 算法分析 归并排序算法的性能 时间复杂度归并排序的形式就是一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的可以得出它的时间复杂度是O(n*log2n)。 空间复杂度由前面的算法说明可知，算法处理过程中，需要一个大小为n的临时存储空间用以保存合并序列。 算法稳定性在归并排序中，相等的元素的顺序不会改变，所以它是稳定的算法。 归并排序和堆排序、快速排序的比较若从空间复杂度来考虑：首选堆排序，其次是快速排序，最后是归并排序。若从稳定性来考虑，应选取归并排序，因为堆排序和快速排序都是不稳定的。若从平均情况下的排序速度考虑，应该选择快速排序。 完整代码 运行结果123456排序前 : 9 1 5 3 4 2 6 8 7 gap = 1: 1 9 3 5 2 4 6 8 7 gap = 2: 1 3 5 9 2 4 6 8 7 gap = 4: 1 2 3 4 5 6 8 9 7 gap = 8: 1 2 3 4 5 6 7 8 9 排序后: 1 2 3 4 5 6 7 8 9]]></content>
      <categories>
        <category>数据结构和算法</category>
        <category>【排序算法】</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法(六)--快速排序]]></title>
    <url>%2F2019%2F05%2F16%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%2F%E3%80%90%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E3%80%91%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-%E5%85%AD-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[算法概念快速排序是一种交换排序，找准一个基值，定义两个指针分别进行移动，与基值进行相比交换，反复进行直到最后形成一个有序的数组。 基本思想通过一趟排序将要排序的数据分割成独立的两部分：分割点左边都是比它小的数，右边都是比它大的数。然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。详细的图解往往比大堆的文字更有说明力，所以直接上图： 上图中，演示了快速排序的处理过程：初始状态为一组无序的数组：2、4、5、1、3。经过以上操作步骤后，完成了第一次的排序，得到新的数组：1、2、5、4、3。新的数组中，以2为分割点，左边都是比2小的数，右边都是比2大的数。2左边的数组只有一个元素1，所以显然不用再排序，位置也被确定。（注：这种情况时，left指针和right指针显然是重合的。因此在代码中，我们可以通过设置判定条件left必须小于right，如果不满足，则不用排序了）。而对于2右边的数组5、4、3，设置left指向5，right指向3，开始继续重复图中的一、二、三、四步骤，对新的数组进行排序。 核心代码 算法分析 快速排序算法的性能 时间复杂度当数据有序时，以第一个关键字为基准分为两个子序列，前一个子序列为空，此时执行效率最差。而当数据随机分布时，以第一个关键字为基准分为两个子序列，两个子序列的元素个数接近相等，此时执行效率最好。所以，数据越随机分布时，快速排序性能越好；数据越接近有序，快速排序性能越差。 空间复杂度快速排序在每次分割的过程中，需要 1 个空间存储基准值。而快速排序的大概需要 Nlog2N次的分割处理，所以占用空间也是 Nlog2N 个。 算法稳定性在快速排序中，相等元素可能会因为分区而交换顺序，所以它是不稳定的算法。 完整参考代码 运行结果12345678数组排序前: 1 3 4 5 2 6 9 7 8 0 base = 1: 0 1 4 5 2 6 9 7 8 3 base = 4: 3 2 4 6 9 7 8 5 base = 3: 2 3 base = 6: 5 6 7 8 9 base = 7: 7 8 9 base = 8: 8 9 数组排序后: 0 1 2 3 4 5 6 7 8 9]]></content>
      <categories>
        <category>数据结构和算法</category>
        <category>【排序算法】</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL基础笔记（2）-- SQL语言]]></title>
    <url>%2F2019%2F05%2F14%2FJavaWeb%2F%E3%80%90MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%91%2Fmysql%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89-sql%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[什么是SQL查询语言？SQL是Structured Quevy Language(结构化查询语言)的缩写。 SQL是专为数据库而建立的操作命令集，是一种功能齐全的数据库语言。在使用它时，只需要 发出“做什么”的命令，“怎么做”是不用使用者考虑的。 SQL数据类型1.常用的数据类型double：浮点型，例如double(5,2)表示最多5位，其中必须有2位小数，即最大值为999.99； char：固定长度字符串类型； char(10) &apos;abc&apos; varchar：可变长度字符串类型；varchar(10) &apos;abc&apos; text：字符串类型; blob：二进制类型； date：日期类型，格式为：yyyy-MM-dd； time：时间类型，格式为：hh:mm:ss datetime:日期时间类型 yyyy-MM-dd hh:mm:ss 在mysql中，字符串类型和日期类型都要用单引号括起来。 如’sql_study’、’2020-01-01’等 MySQL支持的数据类型大致可以分为三类1.数值类型 2.字符串类型 3.日期和时间类型 sql功能分类1.DDL: 数据定义语言DDL是用来定义数据库对象：创建库，表，列等。 创建数据库 create database 数据库名 character set utf8; 修改数据库 alter database 数据库名 charactor set gbk; 查看表的字段信息 DESC 表名; 查看表的创建细节 SHOW CREATE TABLE 表名; 修改表的字符集为gbk ALTER TABLE 表名 CHARACTER SET 字符集名称; 创建表 create table 表名(列名1 列的类型[约束]，列名2 列的类型[约束]....); 修改表名 RENAME TABLE 原始表名 TO 要修改的表名; 修改一个表的字段类型 ALTER TABLE 表名 MODIFY 字段名 数据类型 修改表的列名 ALTER TABLE 表名 CHANGE 原始列名 新列名 数据类型; 删除表 DROP TABLE 表名; 添加一列 ALTER TABLE 表名 ADD 列名 数据类型; 删除一列 ALTER TABLE 表名 DROP 字段名; 2.DML：数据操作语言DML用来操作数据库表中的记录，即就是对数据库的数据进行增删改查的操作 ①查询操作 查询表中的所有数据 SELECT * FROM 表名; 查询表中的指定数据 SELECT * FROM 表名 where 条件; ②插入操作 单个数据插入 INSERT INTO 表名（列名1，列名2 ...）VALUE (列值1，列值2...); 批量数据插入 INSERT INTO 表名（列名1，列名2 ...）VALUES (列值1，列值2...)，(列值1，列值2...); ③更新操作 更新记录 UPDATE 表名 SET 列名1=列值1，列名2=列值2 .... WHERE 列名=值; ④删除操作 删除记录 DELETE FROM 表名 【WHERE 列名=值】; (DELETE 删除表中的数据，表结构还在;删除后的数据可以找回) 删除所有记录 TRUNCATE TABLE 表名; (删除是把表直接DROP掉，然后再创建一个同样的新表。删除的数据不能找回) 3.DQL：数据查询语言DQL用来查询数据。数据库执行DQL语句不会对数据进行改变，而是让数据库发送结果集给客户端。 结果集：通过查询语句查询出来的数据以表的形式展示我们称这个表为虚拟结果集，并存放在内存中。查询返回 的结果集是一张虚拟表。 DQL包含模糊查询、条件查询、字段控制查询、排序、以及聚合函数的应用 4.DCL：数据控制语言DCL用来定义访问权限和安全级别。即对数据库事务（trasaction）的控制，包括事务的提交（commit），事务的回滚（rollback），以及权限的管理等。]]></content>
      <categories>
        <category>JavaWeb</category>
        <category>【MySQL数据库】</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL基础笔记（1）-- 数据库的介绍]]></title>
    <url>%2F2019%2F05%2F13%2FJavaWeb%2F%E3%80%90MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%91%2Fmysql%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[什么是数据库？数据库是是按照数据结构来组织、存储和管理数据的仓库。我们一般说的数据库,就是指的DBMS: 数据库服务器（是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，简称DBMS）.常见的数据库有Oracle、MySQL、SQL Server等等. Oracle: 运行稳定，可移植性高，功能齐全，性能超群！适用于大型企业领域。MySQL:开源，体积小，速度快。适用于于中小型企业领域。SQL Server: 全面，效率高，界面友好，操作容易，但是不跨平台。适用于于中小型企业领域。 数据库系统的专业术语表 具有固定的列数,和任意的行数 数据库 数据库是一些关联表的集合 列 一个数据项 Field 字段 行 一条记录（row） 主键 主键是唯一的。一个数据表中只能包含一个主键。你可以使用主键来查询数据。 外键 外键用于关联两个表 索引 使用索引可快速访问数据库表中的特定信息。索引是对数据库表中一列或多列的值进行排序的一种结构。 类似于书籍的目录。 MySQL数据库1.MySql介绍 MySQL是一个关系型数据库管理系统，属于Oracle公司。MySQL是一种关联数据库管理系统，关联数据库将数据保 存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。Mysql是开源的,而且支持 大型的数据库。可以处理拥有上千万条记录的大型数据库。 MySQL使用标准的SQL数据语言形式。 Mysql可以允许于多个系统上，并且支持多种语言。这些编程语言包括C、C++、Python、Java等。 2.MySql安装 (下载地址 https://dev.mysql.com/downloads/mysql/)3.MySql的存储引擎① 什么是存储引擎 MySQL中的数据用各种不同的技术存储在文件（或者内存）中。这些技术中的每一种技术都使用不同的存储机 制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。通过选择不同的技术，你能够获得额外的速度或 者功能，从而改善你的应用的整体功能。（不同的存储引擎性能是不一样的） ②什么是事务 是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。 4.存储引擎分类MYISAM ：它不支持事务，也不支持外键，尤其是访问速度快，对事务完整性没有要求或者以SELECT、INSERT为主的应 用基本都可以使用这个引擎来创建表。每个MyISAM在磁盘上存储成3个文件，其中文件名和表名都相同，但 是扩展名分别为：.frm(存储表定义)、MYD(MYData，存储数据)、MYI(MYIndex，存储索引) INNODB：InnoDB存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是对比MyISAM的存储引擎，InnoDB写的 处理效率差一些并且会占用更多的磁盘空间以保留数据和索引。 MEMORY：memory使用存在内存中的内容来创建表。每个MEMORY表实际对应一个磁盘文件，格式是.frm。 MEMORY类型的表访问非常快，因为它到数据是放在内存中的，并且默认使用HASH索引，但是一旦服务器关闭， 表中的数据就会丢失，但表还会继续存在。 常用数据库命令1.Mysql数据库的分类 (1)系统数据库 information_schema 存储数据库对象信息如用户表信息,列信息,根除,字符,分区里面的内容我们不能动. performance_schema 存储数据库服务器性能参数信息 mysql 存储数据库用户权限信息 sys 通过这个库可以快速的了解系统的元数据信息（这个库是通过视图的形式把information_schema 和 performance_schema结合起来，查询出更加令人容易理解的数据 (2)用户数据库 用户自己创建的数据库,一个项目用一个数据库 2.Mysql数据库命令]]></content>
      <categories>
        <category>JavaWeb</category>
        <category>【MySQL数据库】</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM三大框架之---SpringMVC]]></title>
    <url>%2F2019%2F05%2F12%2FWeb%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%2FSSM%E6%A1%86%E6%9E%B6-%E3%80%90SpringMVC%E5%AD%A6%E4%B9%A0%E3%80%91%2Fssm%E4%B8%89%E5%A4%A7%E6%A1%86%E6%9E%B6%E4%B9%8B-springmvc%2F</url>
    <content type="text"><![CDATA[表现层框架SpringMVC1.SpringMVC程序开发的基本步骤:123456789101112131415161718192021221.准备好SpringMVC开发的jar包(8个) spring-aop.jar spring-beans.jar spring-context.jar spring-core.jar spring-expression.jar commons-logging.jar spring-web.jar 在Web应用开发过程中，用到Spring框架时所需的核心类库 spring-webmvc.jar Spring MVC框架相关的所有类。如国际化、标签、Theme、FreeMarker等相关类2.在web.xml中配置前置控制器DispatcherServlet，用于拦截与&lt;url-pattern&gt;相匹配的请求 3.开发前端请求页面(index.jsp) 4.开发请求处理类(controller）：含注解@Controller、@RequestMapping()等5.在src目录下创建SpringMVC的配置文件：springmvc.xml &lt;!-- 配置需要扫描的包 --&gt; &lt;context:component-scan base-package=&quot;com.YYcoder.controller&quot;&gt; &lt;/context:component-scan&gt; &lt;!-- 配置视图解析器：把请求处理类的返回值，加工成最终的视图路径--&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;prefix&quot; value=&quot;/views/&quot;&gt;&lt;/property&gt;&lt;!--前缀--&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt;&lt;!--后缀--&gt; &lt;/bean&gt;6.开发前端结果显示页面：result.jsp 2.SpringMVC的学习内容(主要是学会如何使用注解来实现操作) ①常见注解的使用(可以参考springMVC的文档学习) @RequestMapping 用来给方法绑定一个请求映射 @PathVariable 获取动态参数 @RequestParam 获取请求参数 @RequestHeader 获取请求中的“头信息” @CookieValue 可以给处理方法入参绑定某个Cookie值 ②处理模型数据：用户从视图页面(v)发起一个请求到控制器(c)，控制器调用Service/Dao等处理数据， 并从数据库中返回数据(M)。之后控制器拿到数据后加以处理，并返回到视图页面。 实现方法： （1）ModelAndView：含Model和View两部分，数据将被放入request作用域 （2）ModelMap、Map及Model：不含view部分，可以方法的参数操作数据放入request作用域。 （3）@SessionAttribute：把数据放到session作用域 （4）@ModelAttribute：会在请求处理类中的每一个方法执行前都执行一次(谨用) ③视图、视图解析器(ViewResolver),以及对静态资源的处理 ④类型转换：将前端传来的数据类型转为请求处理方法参数中的所对应的类型 ⑤数据格式化、数据校验:让前端传入的数据按照一定格式、要求，否则报错。 ⑥文件上传、拦截器的使用。在springmvc.xml文件中配置： &lt;mvc:interceptors&gt; &lt;!-- 配置自定义的拦截器 --&gt; &lt;bean class=&quot;org.lanqiao.interceptor.FirstInterceptor&quot;&gt;&lt;/bean&gt; &lt;/mvc:interceptors&gt; ⑦异常处理：使用@ExceptionHandler注解用来捕获指定类型的异常。 ⑧SSM整合:Spring + springmvc + Mybatis Spring - Mybatis SqlSessionFactory - &gt; SqlSession -&gt; StduentMapper -&gt;CRUD 整合： 将SqlSessionFactory在spring中配置 Spring - SpringMvc：spring springmvc各自配置一遍 步骤： 1.jar包 2.Student 类 --Student表 3.(省略)--MyBatis配置SqlMapConfig.xml(数据源、 mapper.xml) 在spring配置文件中 applicationContext.xml 4.通过mapper.xml将 类、表建立映射关系 5.web配置spring springmvc 6.spring 整合mybatis 扫描器 7.spring整合springmvc(视图解析器 标准配置) ui层：前端（jsp）---&gt;通过注解调用 后端：SpringMvc（或Servlet） (controller控制器依赖于Service,即给controller注入service) Service层：StudentService.java StduentServiceImpl.java(依赖dao层，即给service注入mapper) &lt;!-- 配置DAO层:为StudentDaoImpl注入SqlSessionFactory对象 --&gt; &lt;bean id=&quot;studentService&quot; class=&quot;org.lanqiao.service.impl.StudentServiceImpl&quot;&gt; &lt;property name=&quot;studentDao&quot; ref=&quot;studentMapper&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;studentController&quot; class=&quot;org.lanqiao.controller.stduentController&quot;&gt; &lt;property name=&quot;studentService&quot; ref=&quot;studentService&quot;&gt;&lt;/property&gt; &lt;/bean&gt; dao层：studentMapper.java() StudentMapper.xml ---&gt;操作DB数据库 控制器 testController.java 业务逻辑层接口 testService.java 业务逻辑层实现类 testServiceImpl.java Web.xml中配置使用Spring和SpringMVC SpringMVC.xml配置扫描包、视图解析器和控制器Controller applicationContext.xml:配置数据库连接池、sqlSessionFactory、dao、service 编写test测试：jsp页面测试]]></content>
      <categories>
        <category>Web后端技术</category>
        <category>SSM框架--【SpringMVC学习】</category>
      </categories>
      <tags>
        <tag>框架学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM三大框架之---Spring]]></title>
    <url>%2F2019%2F05%2F12%2FWeb%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%2FSSM%E6%A1%86%E6%9E%B6-%E3%80%90Spring%E5%AD%A6%E4%B9%A0%E3%80%91%2Fssm%E4%B8%89%E5%A4%A7%E6%A1%86%E6%9E%B6%E4%B9%8B-spring%2F</url>
    <content type="text"><![CDATA[业务层框架Spring1.Spring程序开发的基本步骤:123456789101112131415161718192021222324251.准备好Spring开发的jar包，至少需要： spring-aop.jar 使用Spring的AOP特性时所需的jar类库 spring-beans.jar 包含访问配置文件、创建和管理bean 以及进行IoC/DI操作相关的所有类 spring-context.jar 为Spring核心提供了大量扩展。例如，可以找到使用Spring ApplicationContext 特性时所需的全部类，JDNI所需的全部类，以及校验Validation方面等相关类. spring-core.jar Spring框架的核心类库，Spring各个组件要都要使用到这个包里的类 spring-expression.jar Spring表达式语言需要的类库 可以下载第三方提供的日志jar commons-logging.jar，打印日志 2.开发工具：Eclipse+插件Spring Tool Suite，或者直接下载STS工具3.创建实体类、配置文件(applicationContext.xml)、编写测试类Test &lt;!-- 配置文件 applicationContext.xml，通过&lt;bean&gt;标签实现对象的赋值 --&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;唯一标识符&quot; class=&quot;包名+类名&quot;&gt; &lt;!-- 配置属性： value 值 -&gt; name 字段 --&gt; &lt;property name=&quot;属性&quot; value=&quot;属性值&quot;&gt;&lt;/property&gt; &lt;property name=&quot;属性名&quot; ref=&quot;引用对象的id值&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; 2.Spring的特点(获取对象不需要new，直接从IOC容器拿。前提是要在springIOC中存放对象并赋值)123456//1.创建Spring的IOC容器对象ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicatoinContext.xml&quot;);//2.从IOC容器中获取Bean实例(id为&quot;student&quot;的Student对象)//相当于 Student stu = new Student();Student stu =(Student)context.getBean(&quot;student&quot;);//继续操作 3.spring的学习内容12345678910111213141516171819202122232425262728293031323334353637383940414243444546 IOC(控制反转)：将创建对象、属性值的方式进行了翻转，从new、setXxx()翻转为 从SpringIOC 容器getBean()获取。 DI(依赖注入)：将属性值注入给属性，将属性注入给bean,将bean注入给IOC容器。 IOC容器赋值：基本类型 用 value=&quot; &quot;赋值；对象类型：ref =&quot; 需要引用的对象的id值 &quot;，实现对象与对象之间的依赖关系。 依赖注入的赋值方式： 1.setter注入((底层通过反射实现) 默认使用setter方法()给属性赋值 &lt;property&gt;标签 2.构造器注入：通过构造器注入 &lt;constructor-arg&gt;标签,其内部的属性赋值顺序需要和构造器参数的顺序一致； 如果不一致，则需要通过type、index或name指定顺序。 3.p命名空间注入：①引入命名空间：xmlns:p=&quot;http://www.springframework.org/schema/p&quot; ②&lt;bean&gt;标签里面添加：简单类型(8大类型+String)(p:属性名=&quot;属性值&quot;) 引用类型(p:属性名-ref=&quot;引用对象的id&quot;) ③ 注入各种集合数据类型(List、Set、Map、properties) 都有各自对应的标签使用 List或Array 外层用&lt;list&gt;；内层用&lt;value&gt;或&lt;ref&gt; Set 外层用&lt;set&gt;；内层用&lt;value&gt;或&lt;ref&gt; Map 外层用&lt;map&gt;；中间层用&lt;entry&gt;；内层中键用&lt;key&gt;&lt;value&gt;…&lt;/value&gt;&lt;/key&gt;， 值用&lt;value&gt;…&lt;/value&gt;或&lt;ref&gt;…&lt;/ref&gt; Properties 外层用&lt;props&gt;；内层中键写在&lt;prop key=”..”&gt;..&lt;/prop&gt;的key值中， 值写在&lt;prop&gt;..&lt;/prop&gt;中间。Properties中的键和值通常都是字符串类型。 自动装配： 自动装配 (只适用于ref类型) Course类中有一个ref属性propertyName（属性名），并且ioc容器中也有一个bean为的id也ropertyName autowire=&quot;byName&quot;：自动寻找其他bean的id值 = 该Course的属性名 autowire=&quot;byType&quot;：寻找其他bean的类型（class） = 该Course类的ref属性类型(只能有一个满足要求,否则报错) autowire=&quot;constructor&quot;：寻找其他bean的类型（class） = 该Course类的构造方法参数(本质和byType一样) &lt;bean id=&quot;Course&quot; class=&quot;包名+类名&quot; autowire=&quot;byName或者byType或constructor&quot;&gt; &lt;property name=&quot;...&quot; value=&quot;...&quot;&gt;&lt;/property&gt; &lt;!-- &lt;property name=&quot;...&quot; ref=&quot;...&quot;&gt;&lt;/property&gt; --&gt; &lt;/bean&gt; 注：&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; ... default-autowire=&quot;byName&quot;&gt; 可以一次性将该ioc容器中的所有bean统一设置成自动装配 注解定义bean:实体类添加注解，Spring在启动时，会根据base-package在改包中扫描所有类，查找这些类是否有注解。 如果有，则将该类加入spring ioc 容器。application.xml下添加： &lt;context:component-scan base-package=&quot;实体类所在包名&quot;&gt;&lt;/context:component-scan&gt; 常见注解(@Component)分为： dao层注解(@Repository)、service层注解(@Service)、控制器注解(@Controller) AOP(面向切面编程)：①前置通知 覆盖before()方法 目标方法执行前发生。 ②后置通知 覆盖afterReturning()方法 目标方法执行后发生 ③异常通知 无需覆盖方法 目标方法发生异常时执行 ④最终通知 目标方法执行完毕后,插入的通知（不论是正常返回还是异常退出）。 ④环绕通知 覆盖invoke()方法 拦截对目标方法调用，即调用目标方法的整个过程（功能最强大） Spring整合Mybatis:将Mybatis操作Dao层的权力交给Spring，Spring与其他什么框架整合的时候，权力全部 交由Spring掌控，Spring是老大。]]></content>
      <categories>
        <category>Web后端技术</category>
        <category>SSM框架--【Spring学习】</category>
      </categories>
      <tags>
        <tag>框架学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM三大框架之---MyBatis]]></title>
    <url>%2F2019%2F05%2F12%2FWeb%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF%2FSSM%E6%A1%86%E6%9E%B6-%E3%80%90MyBatis%E5%AD%A6%E4%B9%A0%E3%80%91%2Fssm%E4%B8%89%E5%A4%A7%E6%A1%86%E6%9E%B6%E4%B9%8B-mybatis%2F</url>
    <content type="text"><![CDATA[持久层框架Mybatis1.MyBatis的基本步骤: 12341.mybatis.jar、mysql.jar(数据库连接包);2.conf.xml(数据库配置信息、映射文件)3.表-类：相对应的实体类(属性) 映射关系文件mapper.xml,mapper.java(包含方法的接口)4.编写测试类TestDemo 2.MyBatis的调用实现过程：123456789String resource = &quot;conf.xml&quot;;// 加载mybatis 的配置文件Reader reader = Resources.getResourceAsReader(resource);// 创建sqlSession 的工厂(由XML配置文件（conf.xml）创建SqlSessionFactory)SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader);// 通过SqlSessionFactory创建能够执行SQL映射文件中sql语句的sqlSession对象SqlSession session = sessionFactory.openSession(); //SqlSession对象包含了执行SQL所需要的所有方法，可以直接运行映射的SQL语句,完成对数据的增删改查等操作。 seesion.方法(); 3.MyBatis的学习内容1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374属性文件(db.properties) 全局参数：&lt;settings&gt;&lt;/settings&gt;里面的子标签设置 别名定义：不需要通过全类名的形式(即“包名+类名”),直接用包名访问 1.单个别名 &lt;typeAliases&gt; &lt;typeAlias type=&quot;实体类的对象类型&quot; alias=&quot;别名&quot;/&gt; &lt;/typeAliases&gt; 2.批量别名(包名下所有实体类都自动定义了别名) &lt;typeAliases&gt; &lt;package name=&quot;包名&quot;/&gt; &lt;/typeAliases&gt; 类型转换器：java类型与jdbc类型之间的映射(类型对应不上)，如javaType=&quot;java.lang.Boolean&quot; jdbcType=&quot;INTEGER&quot;，这时需自定义类型处理器，通过实现TypeHandler接口（或继承 BaseTypeHandler抽象类）取值符号： 1.#&#123;参数&#125;，可以防止SQL注入，并且会为传入String类型的参数值自动加上引号（参数名任意）， 但如果查询语句中传入一个int类型的值，则“#&#123;参数&#125;”不会为其加引号。 2.$&#123;value&#125;，来获取输入的参数值.这种方式不能防止SQL注意，有很大的安全隐患。 而且不会为字符串类型的值加上引号(需手动&quot;)，主要用于动态排序(order by). 输入参数(parameterType)：1.简单类型(8钟基本类型+String),输入参数名可任意 2.实体类的对象，要确保$&#123;&#125;或#&#123;&#125;中的参数名必须是实体类的属性名。 3.嵌套对象，A对象包含B对象的属性，可以#&#123;&#125;或$&#123;&#125;来获取传入的A对象的嵌套属性. 参数一般为A.B对象属性名。 4.HashMap:通过$&#123;&#125;或#&#123;&#125;获取key对应的value值。输出参数：1.简单类型，resultType=&quot; 简单类型 &quot; 2.HashMap。resultType=&quot;HashMap&quot; 3.resultMap.(用于处理字段名与属性名不一致) &lt;select&gt;元素中用resultMap的属性值匹配&lt;resultMap&gt; 元素的id值；然后在&lt;resultMap&gt;元素中用type指定相应&lt;select&gt;元素的返回值；并通过&lt;result&gt;子元素 的column指定字段名、property指定与字段名相对应的属性名，从而将字段名和属性名一一对应起来。 &lt;result&gt;元素用来指定普通字段，&lt;id&gt;元素用来指定主键字段。 注：亦可取通过别名形式字段名 &quot;属性名(字段名的别名)&quot;)处理字段名与属性名不一致的问题 动态SQL：MyBatis提供了&lt;if&gt;、&lt;where&gt;、&lt;foreach&gt;等标签来实现SQL语句的动态拼接。 关联查询：1.一对一 ① 业务扩展类(包含所要查询的表的所有属性) ② 使用resultMap实现一对一查询。表与表的外键在实体类使用成员变量表示在mapper.xml通过 &lt;association&gt;将属性与字段绑定起来 javaType=&quot;类型&quot; 2.一对多(多对一，多对多) 将查询的结果放在一个集合中&lt;collection&gt;标签进行字段与属性绑定 oftype=&quot;集合中的类型&quot; 日志输出：配置过程（导入log4j.jar） ① conf.xml文件配置 &lt;configuration&gt; &lt;properties resource=&quot;db.properties&quot; /&gt; &lt;settings&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt; &lt;/settings&gt; &lt;/configuration&gt; ② 编写log4j.properties log4j.rootLogger=DEBUG, stdout log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n 延迟加载：根据需要延迟信息的加载，如一对多情况下，只想查看一的那部分，多的那部分延迟加载。配置加载方式： &lt;settings&gt; &lt;!-- 将延迟加载设置为：true （可省，因为默认值就是true）--&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt; &lt;!-- 将立即加载设置为：false --&gt; &lt;setting name=&quot;aggressiveLazyLoading&quot; value=&quot;false&quot;/&gt; &lt;/settings&gt;缓存:一级缓存：同一个SqlSession对象共享。 第一次执行完查询时，向数据库发送语句，并将数据库的查询结果放入SQLSESSION内存（作为缓存），以后如果 再次执行该相同的查询SQL语句时，就会直接从内存中读取查询结果。 二级缓存：多个SqlSession对象共享的，范围是同一个namespace下SQL映射文件生成的动态代理mapper对象 *注：如果执行了增删改所需的commit()方法，那么SqlSession对象的一级缓存就会被清理（即将缓存中的数据 全部写入数据库，缓存变空）*逆向工程：在MyBatis的开发过程中，数据库表、实体类、SQL映射文件以及动态代理接口四者之间有着非常密切的关系。 只要根据一个，其余三个都能自动生成（依靠下载mybatis-generator-core-1.4.2-bundle.zip）。]]></content>
      <categories>
        <category>Web后端技术</category>
        <category>SSM框架--【MyBatis学习】</category>
      </categories>
      <tags>
        <tag>框架学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[滑动窗口的最大值]]></title>
    <url>%2F2019%2F04%2F23%2F%E5%88%B7%E9%A2%98%2Fnewcoder%2F%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC%2F</url>
    <content type="text"><![CDATA[题目描述 给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。 题解 建立两个指针pLow(初始指向下标为0的位置),pHigh(指向size-1的地方)。以 pHigh &lt; num.length作为循环的条件，依次在list中add滑动窗口的最大值，然后使pLow++，pHigh++，直到循环推出。 代码123456789101112131415161718192021222324import java.util.ArrayList;public class WindowMove &#123; public ArrayList&lt;Integer&gt; maxInWindows(int[] num, int size) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); if (num == null || size &lt; 0) return null; if (size == 0) &#123; return list; &#125; int pLow = 0; int pHigh = pLow + size - 1; while (pHigh &lt; num.length) &#123; int max = 0; for (int i = pLow; i &lt;= pHigh; i++) &#123; if (max &lt; num[i]) max = num[i]; &#125; list.add(max); pLow++; pHigh++; &#125; return list; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
        <category>newcoder</category>
      </categories>
      <tags>
        <tag>nowcoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[确定字符有无重复]]></title>
    <url>%2F2019%2F04%2F23%2F%E5%88%B7%E9%A2%98%2F%E7%A1%AE%E5%AE%9A%E5%AD%97%E7%AC%A6%E6%9C%89%E6%97%A0%E9%87%8D%E5%A4%8D%2F</url>
    <content type="text"><![CDATA[题目描述 请实现一个算法，确定一个字符串的所有字符是否全都不同。给定一个string iniString，请返回一个bool值,True代表所有字符全都不同，False代表存在相同的字符。 代码12345678910111213141516171819202122import java.util.*;public class Different &#123; public boolean checkDifferent(String iniString) &#123; LinkedHashMap&lt;Character, Integer&gt; map = new LinkedHashMap&lt;Character, Integer&gt;(); char[] ch = iniString.toCharArray(); for (int i = 0; i &lt; ch.length; i++) &#123; if (map.containsKey(ch[i])) &#123; int time = map.get(ch[i]); map.put(ch[i], ++time); &#125; else map.put(ch[i], 1); &#125; for (int i = 0; i &lt; ch.length; i++) &#123; if (map.get(ch[i]) &gt; 1) return false; &#125; return true; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>nowcoder</tag>
      </tags>
  </entry>
</search>
